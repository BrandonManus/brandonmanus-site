<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Earth Galaxy Enhanced</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #0b001b; 
      cursor: none; 
    }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js";
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/controls/OrbitControls.js';

// Scene & camera
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
camera.position.set(0, 1.2, 4);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Controls for camera
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enableZoom = false;

// Load textures
const loader = new THREE.TextureLoader();
const earthTexture = loader.load("../assets/earth.png");
const cloudTexture = loader.load("../assets/earth_clouds.png"); // make sure to add cloud texture

// Earth
const earthGeo = new THREE.SphereGeometry(1, 64, 64);
const earthMat = new THREE.MeshStandardMaterial({
  map: earthTexture,
  roughness: 0.5,
  metalness: 0
});
const earth = new THREE.Mesh(earthGeo, earthMat);
scene.add(earth);

// Clouds layer
const cloudGeo = new THREE.SphereGeometry(1.02, 64, 64);
const cloudMat = new THREE.MeshPhongMaterial({
  map: cloudTexture,
  transparent: true,
  opacity: 0.4,
  depthWrite: false
});
const clouds = new THREE.Mesh(cloudGeo, cloudMat);
scene.add(clouds);

// Lights
const ambientLight = new THREE.AmbientLight(0x555555, 0.6);
scene.add(ambientLight);

const pointLight = new THREE.PointLight(0xffffff, 1.5);
pointLight.position.set(5, 3, 5);
scene.add(pointLight);

const mouseLight = new THREE.PointLight(0xff66ff, 1, 10);
scene.add(mouseLight);

// Procedural stars
const starCount = 4000;
const starsGeometry = new THREE.BufferGeometry();
const starPositions = [];
for (let i = 0; i < starCount; i++) {
  starPositions.push((Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400);
}
starsGeometry.setAttribute("position", new THREE.Float32BufferAttribute(starPositions, 3));
const starsMaterial = new THREE.PointsMaterial({ color: 0xbb00ff, size: 0.2, sizeAttenuation: true });
const starField = new THREE.Points(starsGeometry, starsMaterial);
scene.add(starField);

// GUI
const gui = new dat.GUI();
const settings = {
  earthRotationY: 0.01,
  earthRotationX: 0.003,
  cloudRotation: 0.002,
  pointLightColor: "#ffffff"
};

gui.add(settings, 'earthRotationY', 0, 0.1).name("Earth Y Rotation");
gui.add(settings, 'earthRotationX', 0, 0.05).name("Earth X Rotation");
gui.add(settings, 'cloudRotation', 0, 0.01).name("Cloud Rotation");
gui.addColor(settings, 'pointLightColor').name("Point Light").onChange(val => pointLight.color.set(val));

// Mouse tracking
const mouse = { x: 0, y: 0 };
window.addEventListener("mousemove", (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
});

// Animate
function animate() {
  requestAnimationFrame(animate);

  earth.rotation.y += settings.earthRotationY;
  earth.rotation.x += settings.earthRotationX;
  clouds.rotation.y += settings.cloudRotation;

  starField.rotation.y += 0.0005;
  starField.rotation.x += 0.0002;

  // Mouse-following light
  mouseLight.position.x = mouse.x * 5;
  mouseLight.position.y = mouse.y * 5;
  mouseLight.position.z = 2;

  controls.update();
  renderer.render(scene, camera);
}

animate();

// Resize
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
