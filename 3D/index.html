<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>✦ Interactive 3D Earth & Galaxy ✦</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; cursor: none; }
    canvas { display: block; }
    .info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #fff;
      font-family: Arial, sans-serif;
      background: rgba(0,0,0,0.4);
      padding: 10px 15px;
      border-radius: 8px;
      pointer-events: none;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="info">Drag to orbit • Scroll to zoom • Move mouse for magic light • Enjoy the view ✨</div>

  <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/postprocessing/UnrealBloomPass.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 1, 4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Post-processing (bloom for that juicy glow)
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.4,   // strength
      0.4,   // radius
      0.1    // threshold
    );
    composer.addPass(bloomPass);

    // Orbit controls (drag, zoom, auto-rotate option)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.minDistance = 2.5;
    controls.maxDistance = 12;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    // Lights
    scene.add(new THREE.AmbientLight(0x404060, 1));
    scene.add(new THREE.AmbientLight(0x6600cc, 0.3));

    const sunLight = new THREE.PointLight(0xffffff, 3, 100);
    sunLight.position.set(12, 8, 10);
    scene.add(sunLight);

    const mouseLight = new THREE.PointLight(0xff66ff, 1.5, 12);
    scene.add(mouseLight);

    // Texture loader
    const loader = new THREE.TextureLoader();
    const tex = (name) => loader.load(`https://www.solarsystemscope.com/textures/download/2k_${name}`);

    // Earth Group
    const earthGroup = new THREE.Group();
    scene.add(earthGroup);
    earthGroup.rotation.x = THREE.MathUtils.degToRad(23.4); // Earth's tilt

    // Earth
    const earthGeo = new THREE.SphereGeometry(1, 128, 128);
    const earthMat = new THREE.MeshStandardMaterial({
      map: tex('earth_daymap.jpg'),
      normalMap: tex('earth_normal_map.jpg'),
      emissiveMap: tex('earth_nightmap.jpg'),
      emissive: 0xffffff,
      emissiveIntensity: 2.5,
      roughness: 0.9,
      metalness: 0
    });
    const earthMesh = new THREE.Mesh(earthGeo, earthMat);
    earthGroup.add(earthMesh);

    // Clouds
    const cloudsGeo = new THREE.SphereGeometry(1.012, 128, 128);
    const cloudsMat = new THREE.MeshStandardMaterial({
      map: tex('earth_clouds.jpg'),
      alphaMap: tex('earth_clouds.jpg'),
      transparent: true,
      depthWrite: false
    });
    const cloudsMesh = new THREE.Mesh(cloudsGeo, cloudsMat);
    earthGroup.add(cloudsMesh);

    // Atmosphere glow
    const atmosphereGeo = new THREE.SphereGeometry(1.35, 64, 64);
    const atmosphereMat = new THREE.ShaderMaterial({
      vertexShader: `
        varying vec3 vNormal;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec3 vNormal;
        void main() {
          float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
          gl_FragColor = vec4(0.3, 0.6, 1.0, 0.6) * intensity;
        }
      `,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide,
      transparent: true
    });
    const atmosphere = new THREE.Mesh(atmosphereGeo, atmosphereMat);
    earthGroup.add(atmosphere);

    // Moon
    const moonPivot = new THREE.Object3D();
    earthGroup.add(moonPivot);

    const moonGeo = new THREE.SphereGeometry(0.27, 64, 64);
    const moonMat = new THREE.MeshStandardMaterial({
      map: tex('moon.jpg')
    });
    const moon = new THREE.Mesh(moonGeo, moonMat);
    moon.position.set(2.2, 0, 0);
    moonPivot.add(moon);

    // Spiral galaxy starfield (way cooler than random dots)
    const starCount = 12000;
    const positions = new Float32Array(starCount * 3);
    const colors = new Float32Array(starCount * 3);

    for (let i = 0; i < starCount; i++) {
      const i3 = i * 3;

      const radius = Math.random() ** 0.8 * 60;
      const spinAngle = radius * 4;
      const branchAngle = (i % 5) * (Math.PI * 2 / 5) + (Math.random() - 0.5) * 0.3;

      const randomX = Math.pow(Math.random(), 2) * (Math.random() < 0.5 ? 1 : -1) * 3;
      const randomY = (Math.random() - 0.5) * 8;
      const randomZ = Math.pow(Math.random(), 2) * (Math.random() < 0.5 ? 1 : -1) * 3;

      positions[i3]     = Math.cos(spinAngle + branchAngle) * radius + randomX;
      positions[i3 + 1] = randomY;
      positions[i3 + 2] = Math.sin(spinAngle + branchAngle) * radius + randomZ;

      const color = new THREE.Color().setHSL(0.55 + Math.random() * 0.2, 0.6, 0.9);
      colors[i3]     = color.r;
      colors[i3 + 1] = color.g;
      colors[i3 + 2] = color.b;
    }

    const starsGeo = new THREE.BufferGeometry();
    starsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    starsGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const starsMat = new THREE.PointsMaterial({
      size: 0.7,
      sizeAttenuation: true,
      vertexColors: true,
      blending: THREE.AdditiveBlending,
      transparent: true
    });

    const starField = new THREE.Points(starsGeo, starsMat);
    scene.add(starField);

    // Mouse tracking for magic light
    const mouse = { x: 0, y: 0 };
    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });

    // GUI
    const gui = new dat.GUI();
    gui.add(controls, 'autoRotate').name('Auto Rotate');
    gui.add(controls, 'autoRotateSpeed', -5, 5).name('Auto Speed');
    gui.add(bloomPass, 'strength', 0, 3, 0.01).name('Bloom Strength');
    gui.add(bloomPass, 'radius', 0, 1, 0.01).name('Bloom Radius');
    gui.addColor({ lightColor: '#ff66ff' }, 'lightColor').name('Magic Light').onChange(v => mouseLight.color.set(v));
    gui.addColor({ sunColor: '#ffffff' }, 'sunColor').name('Sun Color').onChange(v => sunLight.color.set(v));

    // Animation loop
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const elapsed = clock.getElapsedTime();

      // Earth & clouds rotation
      earthMesh.rotation.y += 0.002;
      cloudsMesh.rotation.y += 0.0035;

      // Moon orbit
      moonPivot.rotation.y += 0.005;

      // Galaxy slow spin
      starField.rotation.y += 0.00015;

      // Magic mouse light follows cursor
      mouseLight.position.set(mouse.x * 7, mouse.y * 7, 3);

      // Gentle star twinkle (global but feels alive)
      starsMat.size = 0.7 + Math.sin(elapsed * 3) * 0.15;

      controls.update();
      composer.render();
    }

    animate();

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
