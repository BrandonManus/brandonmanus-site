<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Orbital Command // 3D Earth</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background-color: #020008;
      cursor: none; 
      font-family: "SF Mono", "Fira Code", Consolas, monospace;
      color: #f5f1ff;
    }
    canvas { display: block; }

    /* Custom cursor: HUD Reticle style */
    .cursor-reticle {
      position: fixed;
      width: 40px;
      height: 40px;
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 100;
      transition: width 0.2s, height 0.2s;
      mix-blend-mode: screen;
    }
    
    .cursor-dot {
      position: fixed;
      width: 6px;
      height: 6px;
      background: #00ffff;
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 101;
      box-shadow: 0 0 10px #00ffff;
    }

    /* When clicking */
    body.clicking .cursor-reticle {
      width: 30px;
      height: 30px;
      border-color: #ff0055;
      background: rgba(255, 0, 85, 0.1);
    }

    /* UI Overlay */
    .hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }

    .hud-header {
      position: absolute;
      top: 24px;
      left: 32px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .hud-title {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      background: linear-gradient(90deg, #fff, #888);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .hud-stats {
      font-size: 10px;
      color: #6699ff;
      opacity: 0.8;
    }

    .hud-bottom {
      position: absolute;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      opacity: 0.7;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: #aaccff;
      text-shadow: 0 0 8px rgba(0, 150, 255, 0.5);
    }

    /* Loading Overlay */
    #loader {
      position: fixed;
      inset: 0;
      background: #000;
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      letter-spacing: 0.3em;
      transition: opacity 1s ease;
      pointer-events: none;
    }

    /* dat.GUI tweaks */
    .dg.ac { z-index: 20 !important; }
    .dg.main .close-button { background-color: #111; }
    .dg .c { background-color: #1a1a1a; }
    .dg .cr.function { border-left: 3px solid #00ffff; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>

  <div id="loader">INITIALIZING ORBITAL SYSTEMS...</div>

  <div class="cursor-reticle" id="cursorRing"></div>
  <div class="cursor-dot" id="cursorDot"></div>

  <div class="hud">
    <div class="hud-header">
      <div class="hud-title">Terra//Vision</div>
      <div class="hud-stats">SYS.ONLINE // WAITING FOR INPUT</div>
    </div>
    <div class="hud-bottom">
      [ CLICK ] LAUNCH SAT · [ DRAG ] ROTATE · [ SCROLL ] ZOOM
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020008, 0.02); // Darker fog for deep space feel

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0.5, 3.5);

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" }); // Antialias off for Bloom performance
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    // --- POST PROCESSING (THE GLOW UP) ---
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // Resolution, Strength, Radius, Threshold
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.strength = 1.5;
    bloomPass.radius = 0.4;
    bloomPass.threshold = 0.15; // Only bright things glow
    composer.addPass(bloomPass);

    // --- CONTROLS ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;
    controls.minDistance = 1.5;
    controls.maxDistance = 10;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    // --- TEXTURES (Using reliable CDNs) ---
    const textureLoader = new THREE.TextureLoader();
    const earthMap = textureLoader.load('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg');
    const earthBump = textureLoader.load('https://unpkg.com/three-globe/example/img/earth-topology.png');
    const earthLights = textureLoader.load('https://unpkg.com/three-globe/example/img/earth-night-lights.png');
    const earthClouds = textureLoader.load('https://unpkg.com/three-globe/example/img/earth-clouds.png');
    
    // Hide loader when textures done (rough approximation)
    THREE.DefaultLoadingManager.onLoad = function ( ) {
        const loader = document.getElementById('loader');
        loader.style.opacity = '0';
        setTimeout(() => loader.remove(), 1000);
    };

    // --- EARTH GROUP ---
    const earthGroup = new THREE.Group();
    earthGroup.rotation.z = 23.4 * Math.PI / 180; // Axial tilt
    scene.add(earthGroup);

    // 1. The Earth Sphere
    const earthGeo = new THREE.SphereGeometry(1, 64, 64);
    const earthMat = new THREE.MeshStandardMaterial({
      map: earthMap,
      bumpMap: earthBump,
      bumpScale: 0.05,
      emissiveMap: earthLights,
      emissive: new THREE.Color(0xffff88),
      emissiveIntensity: 0, // Starts off (controlled by sun angle in complex setups, or GUI here)
      roughness: 0.6,
      metalness: 0.1
    });
    const earth = new THREE.Mesh(earthGeo, earthMat);
    earthGroup.add(earth);

    // 2. Cloud Sphere (Slightly larger)
    const cloudGeo = new THREE.SphereGeometry(1.01, 64, 64);
    const cloudMat = new THREE.MeshStandardMaterial({
      map: earthClouds,
      transparent: true,
      opacity: 0.4,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide,
      depthWrite: false // Fixes transparency sorting issues
    });
    const clouds = new THREE.Mesh(cloudGeo, cloudMat);
    earthGroup.add(clouds);

    // 3. Custom Atmosphere Glow (Fresnel Shader)
    const vertexShader = `
      varying vec3 vNormal;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    const fragmentShader = `
      varying vec3 vNormal;
      void main() {
        float intensity = pow(0.65 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
        gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
      }
    `;
    
    const atmosGeo = new THREE.SphereGeometry(1.2, 64, 64);
    const atmosMat = new THREE.ShaderMaterial({
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide,
      transparent: true,
      depthWrite: false
    });
    const atmosphere = new THREE.Mesh(atmosGeo, atmosMat);
    scene.add(atmosphere); // Add to scene, not group, so it doesn't tilt with earth

    // --- LIGHTING ---
    const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
    sunLight.position.set(5, 3, 5);
    scene.add(sunLight);

    const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft fill
    scene.add(ambientLight);

    const blueBacklight = new THREE.DirectionalLight(0x0033ff, 1.5);
    blueBacklight.position.set(-5, -2, -5);
    scene.add(blueBacklight);

    // --- STARS ---
    const starCount = 3000;
    const starGeo = new THREE.BufferGeometry();
    const starPos = [];
    const starColors = [];
    const color1 = new THREE.Color(0x44aaff);
    const color2 = new THREE.Color(0xffaaff);

    for(let i=0; i<starCount; i++) {
        const r = 20 + Math.random() * 80;
        const theta = 2 * Math.PI * Math.random();
        const phi = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        starPos.push(x,y,z);
        
        // Color variation
        const c = Math.random() > 0.5 ? color1 : color2;
        starColors.push(c.r, c.g, c.b);
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));

    const starMat = new THREE.PointsMaterial({
        size: 0.15,
        vertexColors: true,
        transparent: true,
        opacity: 0.8
    });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);


    // --- SATELLITE SYSTEM ---
    const satellites = [];
    const satGeo = new THREE.BoxGeometry(0.05, 0.02, 0.02);
    const satPanelGeo = new THREE.BoxGeometry(0.12, 0.01, 0.04);
    
    // High emissive material to make them GLOW with the bloom pass
    const satMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
    const panelMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });

    function createSatellite(posVector) {
        const group = new THREE.Group();
        
        const body = new THREE.Mesh(satGeo, satMat);
        const left = new THREE.Mesh(satPanelGeo, panelMat);
        const right = new THREE.Mesh(satPanelGeo, panelMat);
        left.position.x = -0.09;
        right.position.x = 0.09;
        
        group.add(body, left, right);
        
        // Calculate orbit properties
        const distance = posVector.length();
        group.position.copy(posVector);
        group.lookAt(new THREE.Vector3(0,0,0));
        
        // Random orbit axis
        const axis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
        
        satellites.push({ 
            mesh: group, 
            axis: axis, 
            speed: 0.005 + Math.random() * 0.01,
            distance: distance 
        });
        
        scene.add(group);
        
        // Limit max sats
        if(satellites.length > 30) {
            const old = satellites.shift();
            scene.remove(old.mesh);
        }
    }

    // --- INTERACTION ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const cursorRing = document.getElementById('cursorRing');
    const cursorDot = document.getElementById('cursorDot');

    window.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

        cursorRing.style.left = e.clientX + 'px';
        cursorRing.style.top = e.clientY + 'px';
        cursorDot.style.left = e.clientX + 'px';
        cursorDot.style.top = e.clientY + 'px';
    });

    window.addEventListener('mousedown', () => document.body.classList.add('clicking'));
    window.addEventListener('mouseup', () => document.body.classList.remove('clicking'));

    window.addEventListener('click', (e) => {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(earth);
        
        let spawnPos;
        if(intersects.length > 0) {
            // Spawn above the clicked point
            spawnPos = intersects[0].point.normalize().multiplyScalar(1.5);
        } else {
            // Spawn in space
            raycaster.ray.at(2, spawnPos = new THREE.Vector3());
        }
        createSatellite(spawnPos);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- GUI ---
    const gui = new dat.GUI();
    const params = {
        rotationSpeed: 0.5,
        bloomStrength: 1.5,
        bloomThreshold: 0.15,
        cityLights: 2.0,
        cloudSpeed: 0.0005,
    };

    gui.add(params, 'rotationSpeed', 0, 5).name('Auto Rotate').onChange(v => controls.autoRotateSpeed = v);
    gui.add(params, 'bloomStrength', 0, 3).name('Glow Strength').onChange(v => bloomPass.strength = v);
    gui.add(params, 'cityLights', 0, 5).name('City Lights').onChange(v => earthMat.emissiveIntensity = v);
    gui.add(params, 'cloudSpeed', 0, 0.01).name('Cloud Speed');

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const delta = clock.getDelta();

        controls.update();

        // Rotate clouds independently
        clouds.rotation.y += params.cloudSpeed;

        // Rotate stars slowly
        stars.rotation.y -= 0.0002;

        // Animate Satellites
        satellites.forEach(sat => {
            // Rotate position around (0,0,0) using axis
            sat.mesh.position.applyAxisAngle(sat.axis, sat.speed);
            sat.mesh.lookAt(0,0,0);
            sat.mesh.rotateY(Math.PI/2); // Orient panels
        });
        
        // Render via Composer (Bloom) instead of standard renderer
        composer.render();
    }

    animate();
  </script>
</body>
</html>
