<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SOLAR DRIFT // HYPER-V</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }

        /* Cyberpunk UI Overlay */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            box-shadow: inset 0 0 80px rgba(0, 0, 0, 0.8);
        }

        .panel {
            position: absolute;
            background: linear-gradient(180deg, rgba(0, 20, 40, 0.8) 0%, rgba(0,0,0,0.6) 100%);
            border-left: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px;
            text-shadow: 0 0 5px #00ffff;
            font-size: 14px;
        }

        #top-left { top: 20px; left: 20px; }
        #bottom-center { 
            bottom: 20px; left: 50%; transform: translateX(-50%); 
            text-align: center; border: 1px solid #00ffff; border-radius: 20px;
            background: rgba(0,0,0,0.8);
            width: 300px;
        }
        #top-right { top: 20px; right: 20px; border-left: none; border-right: 2px solid #00ffff; text-align: right;}

        h1 { margin: 0 0 5px 0; font-size: 20px; letter-spacing: 3px; }
        .stat-label { font-size: 10px; opacity: 0.7; display: block; margin-top: 5px; }
        .stat-val { font-size: 18px; font-weight: bold; }

        /* Upload Button */
        .upload-wrapper { pointer-events: auto; display: inline-block; margin-top: 10px; }
        input[type="file"] { display: none; }
        .btn {
            background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff; color: #00ffff;
            padding: 8px 16px; cursor: pointer; font-family: inherit; transition: 0.3s;
        }
        .btn:hover { background: #00ffff; color: #000; box-shadow: 0 0 15px #00ffff; }

        /* Warp Effect UI */
        #warp-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(0, 255, 255, 0.2) 100%);
            opacity: 0; transition: opacity 0.2s; pointer-events: none;
        }
        .blink { animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.3; } }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="warp-overlay"></div>
    <div id="hud">
        <div id="top-left" class="panel">
            <h1>SOLAR DRIFT</h1>
            <span class="stat-label">SYSTEM STATUS</span>
            <span class="stat-val blink">ONLINE</span>
            
            <div class="upload-wrapper">
                <label class="btn">
                    UPLOAD SHIP (.GLB / .PNG)
                    <input type="file" id="fileInput" accept=".glb,.gltf,.png,.jpg">
                </label>
            </div>
        </div>

        <div id="top-right" class="panel">
            <span class="stat-label">NEAREST CELESTIAL BODY</span>
            <span class="stat-val" id="target-name">SCANNING...</span>
            <span class="stat-label">DISTANCE</span>
            <span class="stat-val" id="target-dist">0 KM</span>
        </div>

        <div id="bottom-center" class="panel">
            <span class="stat-label">VELOCITY</span>
            <span id="speed-bar" style="display:block; width:0%; height:4px; background:#00ffff; margin: 5px auto;"></span>
            <div style="margin-top:5px;">WASD to Fly | SPACE to WARP</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIG ---
        // "Toy Scale" allows us to see planets without traveling for real-time years
        const SCALE_FACTOR = 1; 
        
        const PLANET_DATA = [
            { name: "SUN", size: 80, dist: 0, color: 0xffaa00, emissive: 0xff5500 },
            { name: "MERCURY", size: 4, dist: 150, color: 0xaaaaaa },
            { name: "VENUS", size: 8, dist: 250, color: 0xffcc99 },
            { name: "EARTH", size: 9, dist: 400, color: 0x2244ff, cloud: true },
            { name: "MARS", size: 5, dist: 550, color: 0xff3300 },
            { name: "JUPITER", size: 35, dist: 900, color: 0xd9a873 },
            { name: "SATURN", size: 28, dist: 1300, color: 0xeebb88, rings: true },
            { name: "URANUS", size: 12, dist: 1700, color: 0x99ffff },
            { name: "NEPTUNE", size: 11, dist: 2000, color: 0x3333ff }
        ];

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000005, 0.0002); // Deep space fog

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0x404040); // Soft ambient
        scene.add(ambientLight);

        // The Sun is the main light source
        const sunLight = new THREE.PointLight(0xffffff, 2.5, 5000, 1);
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);

        // --- OBJECTS ---
        const planets = [];
        const celestialGroup = new THREE.Group();
        scene.add(celestialGroup);

        const textureLoader = new THREE.TextureLoader();

        // Helper to create planets
        PLANET_DATA.forEach(data => {
            const geometry = new THREE.SphereGeometry(data.size, 64, 64);
            const material = new THREE.MeshStandardMaterial({
                color: data.color,
                roughness: 0.8,
                metalness: 0.1,
                emissive: data.emissive || 0x000000,
                emissiveIntensity: 1
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            // Random start angle for orbit
            const angle = Math.random() * Math.PI * 2;
            mesh.position.set(Math.cos(angle) * data.dist, 0, Math.sin(angle) * data.dist);
            
            mesh.userData = { name: data.name, orbitDist: data.dist, orbitSpeed: 100 / (data.dist + 10), angle: angle };
            
            celestialGroup.add(mesh);
            planets.push(mesh);

            // Special: Earth Clouds
            if(data.cloud) {
                const cGeo = new THREE.SphereGeometry(data.size + 0.5, 32, 32);
                const cMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
                const clouds = new THREE.Mesh(cGeo, cMat);
                mesh.add(clouds);
            }

            // Special: Saturn Rings
            if(data.rings) {
                const rGeo = new THREE.RingGeometry(data.size + 5, data.size + 20, 64);
                const rMat = new THREE.MeshBasicMaterial({ color: 0xaa9977, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
                // UV mapping fix for rings
                const pos = rGeo.attributes.position;
                const uv = rGeo.attributes.uv;
                for ( let i = 0; i < pos.count; i ++ ) {
                    const x = pos.getX( i );
                    const y = pos.getY( i );
                    uv.setXY( i, x < 0 ? 0 : 1, y < 0 ? 0 : 1 ); // Simple mapping
                }
                const ring = new THREE.Mesh(rGeo, rMat);
                ring.rotation.x = Math.PI / 2;
                mesh.add(ring);
            }
        });

        // --- STARFIELD (WARP EFFECT) ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 4000;
        const starPos = new Float32Array(starCount * 3);
        const starVel = []; // To store individual star quirks
        
        for(let i=0; i<starCount*3; i++) {
            starPos[i] = (Math.random() - 0.5) * 4000;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });
        const starSystem = new THREE.Points(starGeo, starMat);
        scene.add(starSystem);


        // --- PLAYER SHIP ---
        const playerGroup = new THREE.Group();
        // Start near Earth
        const earthStart = planets.find(p => p.userData.name === "EARTH");
        playerGroup.position.set(earthStart.position.x + 20, 0, earthStart.position.z + 20);
        scene.add(playerGroup);

        let playerShip;
        const defaultShipGeo = new THREE.ConeGeometry(0.5, 2, 8);
        defaultShipGeo.rotateX(Math.PI/2);
        const defaultShipMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x004444 });
        playerShip = new THREE.Mesh(defaultShipGeo, defaultShipMat);
        playerGroup.add(playerShip);

        // --- PHYSICS & CONTROLS ---
        let speed = 0;
        const normalMaxSpeed = 0.8;
        const warpMaxSpeed = 30.0; // HUGE speed for solar travel
        let currentMaxSpeed = normalMaxSpeed;
        let velocity = new THREE.Vector3();
        let rotationVelocity = new THREE.Vector2();
        const keys = { w: false, s: false, a: false, d: false, space: false };
        const mouse = { x: 0, y: 0 };

        // Event Listeners
        window.addEventListener('keydown', (e) => {
            if(e.key.toLowerCase() === 'w') keys.w = true;
            if(e.key.toLowerCase() === 's') keys.s = true;
            if(e.key.toLowerCase() === 'a') keys.a = true;
            if(e.key.toLowerCase() === 'd') keys.d = true;
            if(e.code === 'Space') keys.space = true;
        });
        window.addEventListener('keyup', (e) => {
            if(e.key.toLowerCase() === 'w') keys.w = false;
            if(e.key.toLowerCase() === 's') keys.s = false;
            if(e.key.toLowerCase() === 'a') keys.a = false;
            if(e.key.toLowerCase() === 'd') keys.d = false;
            if(e.code === 'Space') keys.space = false;
        });
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // --- FILE UPLOAD ---
        const loader = new GLTFLoader();
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const url = URL.createObjectURL(file);
            const ext = file.name.split('.').pop().toLowerCase();

            if(['glb','gltf'].includes(ext)){
                loader.load(url, (gltf) => {
                    playerGroup.remove(playerShip);
                    playerShip = gltf.scene;
                    // Normalize Scale
                    const box = new THREE.Box3().setFromObject(playerShip);
                    const size = box.getSize(new THREE.Vector3());
                    const scale = 2 / Math.max(size.x, size.y, size.z);
                    playerShip.scale.setScalar(scale);
                    playerShip.rotation.y = Math.PI; // Often needed
                    playerGroup.add(playerShip);
                });
            } else if(['png','jpg'].includes(ext)) {
                new THREE.TextureLoader().load(url, (tex) => {
                    playerGroup.remove(playerShip);
                    const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
                    const ratio = tex.image.height / tex.image.width;
                    const geo = new THREE.PlaneGeometry(3, 3*ratio);
                    playerShip = new THREE.Mesh(geo, mat);
                    playerShip.rotation.x = -Math.PI/2; 
                    playerShip.rotation.y = Math.PI;
                    playerGroup.add(playerShip);
                });
            }
        });


        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // 1. Planet Orbits (They move slowly)
            planets.forEach(p => {
                if(p.userData.name === "SUN") return;
                p.userData.angle += p.userData.orbitSpeed * 0.005 * delta;
                p.position.x = Math.cos(p.userData.angle) * p.userData.orbitDist;
                p.position.z = Math.sin(p.userData.angle) * p.userData.orbitDist;
                p.rotation.y += 0.5 * delta;
            });

            // 2. Ship Physics
            const isWarp = keys.space;
            const targetMax = isWarp ? warpMaxSpeed : normalMaxSpeed;
            
            // Acceleration
            if(keys.w) speed += 20.0 * delta;
            else if(keys.s) speed -= 20.0 * delta;
            else speed -= speed * 2.0 * delta; // Friction
            
            // Clamp speed
            speed = Math.max(0, Math.min(speed, targetMax));

            // Turning (Mouse controls Pitch/Yaw, A/D controls Roll)
            playerGroup.rotateY(-mouse.x * 1.5 * delta);
            playerGroup.rotateX(mouse.y * 1.5 * delta);
            if(keys.a) playerGroup.rotateZ(2.0 * delta);
            if(keys.d) playerGroup.rotateZ(-2.0 * delta);

            // Move forward based on rotation
            playerGroup.translateZ(speed * 100 * delta); // Multiplier for scale

            // 3. Visual Effects (Warp)
            const fovTarget = isWarp ? 110 : 60;
            camera.fov += (fovTarget - camera.fov) * 0.05;
            camera.updateProjectionMatrix();

            // Shake effect at high speed
            if(isWarp && speed > 10) {
                playerShip.position.x = (Math.random()-0.5) * 0.1;
                playerShip.position.y = (Math.random()-0.5) * 0.1;
                document.getElementById('warp-overlay').style.opacity = (speed/warpMaxSpeed) * 0.8;
            } else {
                playerShip.position.set(0,0,0);
                document.getElementById('warp-overlay').style.opacity = 0;
            }

            // 4. Camera Chase
            // Get position behind ship
            const relativeCameraOffset = new THREE.Vector3(0, 5 + (speed/5), -15 - (speed/2));
            const cameraOffset = relativeCameraOffset.applyMatrix4(playerGroup.matrixWorld);
            
            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(playerGroup.position);

            // 5. HUD Data
            // Find nearest planet
            let nearest = null;
            let minDist = Infinity;
            planets.forEach(p => {
                const dist = playerGroup.position.distanceTo(p.position);
                if(dist < minDist) {
                    minDist = dist;
                    nearest = p;
                }
            });

            if(nearest) {
                document.getElementById('target-name').innerText = nearest.userData.name;
                document.getElementById('target-dist').innerText = Math.floor(minDist) + " MKm";
            }
            document.getElementById('speed-bar').style.width = (speed / warpMaxSpeed * 100) + "%";

            // Render
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
