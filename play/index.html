<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SOLAR DRIFT: INTERCEPTOR</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Courier New', monospace; 
            user-select: none; /* Prevents highlighting text while shooting */
        }
        canvas { display: block; }

        /* HUD STYLING */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        .panel {
            position: absolute;
            background: rgba(0, 10, 0, 0.8);
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            transform: skew(-5deg); /* Cyberpunk tilt */
        }

        #top-left { top: 20px; left: 20px; }
        #bottom-center { 
            bottom: 30px; left: 50%; transform: translateX(-50%) skew(-5deg);
            text-align: center; width: 400px;
        }
        #reticle {
            position: absolute; top: 50%; left: 50%;
            width: 40px; height: 40px;
            border: 1px solid rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #reticle::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: #00ff00;
            transform: translate(-50%, -50%);
        }

        .bar-container { width: 100%; background: #003300; height: 6px; margin-top: 5px; }
        .bar-fill { height: 100%; background: #00ff00; width: 0%; transition: width 0.1s; }
        
        /* Upload UI */
        .upload-btn {
            pointer-events: auto;
            background: transparent; color: #00ff00; border: 1px solid #00ff00;
            padding: 5px 10px; cursor: pointer; font-size: 12px; margin-top: 10px;
            display: inline-block; text-decoration: none;
        }
        input[type="file"] { display: none; }

        /* Warp tunnel effect */
        #warp-fx {
            position: absolute; inset: 0;
            background: radial-gradient(circle, transparent 40%, rgba(0,255,255, 0.1) 90%);
            opacity: 0; transition: opacity 0.5s;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="warp-fx"></div>
    <div id="reticle"></div>

    <div id="hud">
        <div id="top-left" class="panel">
            <strong>SYSTEMS ONLINE</strong><br>
            <span style="font-size:12px; opacity:0.7;">WEAPONS HOT</span>
            <br>
            <label class="upload-btn">
                CHANGE SHIP
                <input type="file" id="fileInput" accept=".glb,.gltf,.png,.jpg">
            </label>
        </div>

        <div id="bottom-center" class="panel">
            <div style="display:flex; justify-content:space-between; font-size:12px;">
                <span>THRUST (SHIFT)</span>
                <span>WARP (SPACE)</span>
            </div>
            <div class="bar-container"><div id="speed-bar" class="bar-fill"></div></div>
            <div style="margin-top:8px; font-size:10px; opacity:0.8;">
                W/S: PITCH | A/D: YAW | CLICK: PLASMA
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0003); // Deep space darkness

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 30000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);
        const sunLight = new THREE.PointLight(0xffffff, 3, 10000, 1); // The Sun
        scene.add(sunLight);

        // --- SOLAR SYSTEM (Simplified) ---
        const planets = [];
        const celestialGroup = new THREE.Group();
        scene.add(celestialGroup);

        // Sun
        const sunGeo = new THREE.SphereGeometry(100, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        // Sun Glow
        const sunGlow = new THREE.Mesh(
            new THREE.SphereGeometry(120, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.3, side: THREE.BackSide })
        );
        sun.add(sunGlow);
        celestialGroup.add(sun);
        planets.push({ mesh: sun, name: "SUN", speed: 0, dist: 0 });

        // Planet Generator
        function createPlanet(size, dist, color, name) {
            const geo = new THREE.SphereGeometry(size, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, roughness: 0.7, metalness: 0.2 
            });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Orbit logic
            const angle = Math.random() * 6.28;
            mesh.position.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
            
            // Add Orbit Ring Visual
            const ringGeo = new THREE.RingGeometry(dist-0.5, dist+0.5, 128);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide, transparent:true, opacity:0.3 });
            const orbitRing = new THREE.Mesh(ringGeo, ringMat);
            orbitRing.rotation.x = Math.PI/2;
            celestialGroup.add(orbitRing);

            mesh.userData = { angle: angle, dist: dist, speed: 50/dist };
            celestialGroup.add(mesh);
            planets.push({ mesh: mesh, name: name });
            return mesh;
        }

        createPlanet(10, 300, 0x00ccff, "EARTH");
        createPlanet(8, 500, 0xff3300, "MARS");
        createPlanet(30, 900, 0xffaa88, "JUPITER");
        createPlanet(25, 1400, 0xccbb99, "SATURN");

        // --- STARS ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<3000; i++) {
            starPos.push((Math.random()-0.5)*4000, (Math.random()-0.5)*4000, (Math.random()-0.5)*4000);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({color:0xffffff, size: 0.8});
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- PLAYER ---
        const playerGroup = new THREE.Group();
        playerGroup.position.set(320, 0, 20); // Start near Earth
        playerGroup.rotation.y = Math.PI; // Face sun roughly
        scene.add(playerGroup);

        // Ship Model
        let playerShip;
        const loadDefaultShip = () => {
            const geo = new THREE.ConeGeometry(1, 4, 8);
            geo.rotateX(Math.PI/2);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.2, metalness: 0.8 });
            playerShip = new THREE.Mesh(geo, mat);
            playerGroup.add(playerShip);
        };
        loadDefaultShip();

        // --- LASER SYSTEM ---
        const lasers = [];
        const laserGeo = new THREE.CylinderGeometry(0.2, 0.2, 8, 8);
        laserGeo.rotateX(Math.PI/2); // Point forward
        const laserMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, blending: THREE.AdditiveBlending });
        
        window.addEventListener('mousedown', () => {
            const laser = new THREE.Mesh(laserGeo, laserMat);
            
            // Spawn at ship position
            laser.position.copy(playerGroup.position);
            laser.quaternion.copy(playerGroup.quaternion);
            
            // Offset slightly forward so we don't shoot ourselves
            laser.translateZ(5);
            
            scene.add(laser);
            lasers.push({ mesh: laser, life: 100 }); // Life = frames until death

            // Visual Recoil
            if(playerShip) playerShip.position.z += 0.5;
        });

        // --- CONTROLS & PHYSICS ---
        const keys = { w:false, a:false, s:false, d:false, shift:false, space:false };
        let speed = 0;
        const MAX_SPEED = 2.0;
        const WARP_SPEED = 40.0;
        const ROT_SPEED = 1.5;

        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            if(key === 'w') keys.w = true;
            if(key === 's') keys.s = true;
            if(key === 'a') keys.a = true;
            if(key === 'd') keys.d = true;
            if(e.key === 'Shift') keys.shift = true;
            if(e.code === 'Space') keys.space = true;
        });
        window.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();
            if(key === 'w') keys.w = false;
            if(key === 's') keys.s = false;
            if(key === 'a') keys.a = false;
            if(key === 'd') keys.d = false;
            if(e.key === 'Shift') keys.shift = false;
            if(e.code === 'Space') keys.space = false;
        });

        // --- FILE UPLOAD ---
        const gltfLoader = new GLTFLoader();
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const url = URL.createObjectURL(file);
            
            if(file.name.match(/\.(glb|gltf)$/i)) {
                gltfLoader.load(url, (gltf) => {
                    playerGroup.remove(playerShip);
                    playerShip = gltf.scene;
                    // Normalize scale
                    const box = new THREE.Box3().setFromObject(playerShip);
                    const size = box.getSize(new THREE.Vector3());
                    const scale = 4 / Math.max(size.x, size.y, size.z);
                    playerShip.scale.setScalar(scale);
                    playerShip.rotation.y = Math.PI; 
                    playerGroup.add(playerShip);
                });
            } else if(file.name.match(/\.(png|jpg|jpeg)$/i)) {
                new THREE.TextureLoader().load(url, (tex) => {
                    playerGroup.remove(playerShip);
                    const aspect = tex.image.height/tex.image.width;
                    playerShip = new THREE.Mesh(
                        new THREE.PlaneGeometry(4, 4*aspect),
                        new THREE.MeshBasicMaterial({ map:tex, transparent:true, side:THREE.DoubleSide })
                    );
                    playerShip.rotation.x = -Math.PI/2;
                    playerShip.rotation.y = Math.PI;
                    playerGroup.add(playerShip);
                });
            }
        });

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // 1. Ship Rotation (WASD)
            if(keys.w) playerGroup.rotateX(ROT_SPEED * delta);  // Pitch Up
            if(keys.s) playerGroup.rotateX(-ROT_SPEED * delta); // Pitch Down
            if(keys.a) playerGroup.rotateY(ROT_SPEED * delta);  // Yaw Left
            if(keys.d) playerGroup.rotateY(-ROT_SPEED * delta); // Yaw Right

            // 2. Ship Speed
            let targetSpeed = 0;
            if(keys.space) targetSpeed = WARP_SPEED;
            else if(keys.shift) targetSpeed = MAX_SPEED;
            
            // Smooth acceleration
            speed += (targetSpeed - speed) * 2.0 * delta;
            
            // Apply movement (Always move forward)
            playerGroup.translateZ(speed * 50 * delta);

            // 3. Camera Follow (Third Person)
            // Calculate ideal position behind ship
            const idealOffset = new THREE.Vector3(0, 6 + (speed*0.2), -15 - (speed*0.5)); 
            idealOffset.applyMatrix4(playerGroup.matrixWorld);
            
            camera.position.lerp(idealOffset, 0.1);
            camera.lookAt(playerGroup.position);

            // 4. Laser Logic
            for(let i = lasers.length - 1; i >= 0; i--) {
                const l = lasers[i];
                l.mesh.translateZ(200 * delta); // Lasers are fast
                l.life--;
                if(l.life <= 0) {
                    scene.remove(l.mesh);
                    lasers.splice(i, 1);
                }
            }

            // 5. Recoil Recovery
            if(playerShip && playerShip.position.z > 0) {
                playerShip.position.z -= 5 * delta;
                if(playerShip.position.z < 0) playerShip.position.z = 0;
            }

            // 6. Warp Visuals
            const warpEl = document.getElementById('warp-fx');
            if(speed > 5) {
                warpEl.style.opacity = (speed / WARP_SPEED) * 0.8;
                camera.fov = 60 + (speed);
            } else {
                warpEl.style.opacity = 0;
                camera.fov = 60;
            }
            camera.updateProjectionMatrix();

            // 7. HUD Update
            document.getElementById('speed-bar').style.width = Math.min(100, (speed / MAX_SPEED) * 100) + '%';

            // Render
            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
