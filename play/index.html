<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NEON VANGUARD // V2</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', monospace; user-select: none; }
        canvas { display: block; }

        /* --- HUD --- */
        #ui-layer {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
        }

        .stat-box { text-shadow: 0 0 10px currentColor; }
        .big-text { font-size: 24px; font-weight: 900; letter-spacing: 2px; }
        .sub-text { font-size: 14px; opacity: 0.8; font-weight: bold; }

        /* Health Bar */
        .hp-container { width: 250px; height: 8px; background: #220000; margin-top: 5px; border: 1px solid #ff0055; transform: skewX(-15deg); }
        .hp-fill { width: 100%; height: 100%; background: #ff0055; transition: width 0.2s; }

        /* Artificial Horizon (The Line that keeps you oriented) */
        #horizon-wrapper {
            position: absolute; top: 50%; left: 50%;
            width: 400px; height: 400px;
            transform: translate(-50%, -50%);
            overflow: hidden;
            opacity: 0.5;
        }
        #horizon-line {
            position: absolute; top: 50%; left: -50%; right: -50%;
            height: 2px; background: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 10px cyan;
            /* This will rotate via JS */
        }

        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 2px;
        }

        /* Bottom Info */
        .hud-bottom {
            padding: 20px; text-align: center;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            color: #888; font-size: 12px;
        }

        /* Upload Button */
        .upload-btn {
            pointer-events: auto; cursor: pointer;
            background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff;
            color: #00ffff; padding: 4px 12px; font-size: 11px;
            text-decoration: none; display: inline-block; margin-top: 8px;
        }
        input[type="file"] { display: none; }

        /* Damage Flash */
        #flash { position: absolute; inset: 0; background: white; opacity: 0; pointer-events: none; transition: opacity 0.1s; mix-blend-mode: overlay; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="flash"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-box" style="color: #ff0055;">
                <div class="sub-text">SHIELD INTEGRITY</div>
                <div class="hp-container"><div id="hp-bar" class="hp-fill"></div></div>
                <label class="upload-btn">
                    UPLOAD SHIP
                    <input type="file" id="fileInput" accept=".glb,.gltf,.png,.jpg">
                </label>
            </div>
            <div class="stat-box" style="color: #00ffff; text-align: right;">
                <div class="big-text" id="score">0</div>
                <div class="sub-text">SCORE</div>
                <div class="sub-text" style="color: #ffff00; margin-top:5px;">COMBO x<span id="combo">1</span></div>
            </div>
        </div>

        <div id="horizon-wrapper"><div id="horizon-line"></div></div>
        <div id="crosshair"></div>

        <div class="hud-bottom">
            WASD: Pilot (Smoothed) | SHIFT: Boost | CLICK: Fire
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- CONFIG ---
        const SETTINGS = {
            turnSpeed: 0.8,    // Lower = Slower Turning
            pitchSpeed: 0.6,   // Lower = Slower Pitching
            inertia: 0.92,     // Higher (0-1) = More "slide/weight"
            maxBank: 0.5       // How much the ship rolls visually when turning
        };

        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0025);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS ---
        const ambient = new THREE.AmbientLight(0x202020);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(50, 100, 50);
        scene.add(sun);

        // --- WORLD REFERENCE (The Grids) ---
        // Floor (Blue)
        const floorGrid = new THREE.GridHelper(4000, 200, 0x0044ff, 0x001133);
        floorGrid.position.y = -100;
        scene.add(floorGrid);

        // Ceiling (Red - subtle)
        const ceilingGrid = new THREE.GridHelper(4000, 200, 0xff0044, 0x330011);
        ceilingGrid.position.y = 300;
        scene.add(ceilingGrid);

        // Stars
        const starsGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<8000; i++) {
            starPos.push((Math.random()-0.5)*5000, (Math.random()-0.5)*5000, (Math.random()-0.5)*5000);
        }
        starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({color:0xaaaaaa, size: 0.9}));
        scene.add(stars);

        // --- PLAYER ---
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);
        
        let playerShip;
        const defaultMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.8, emissive: 0x00ffff, emissiveIntensity: 0.5 });

        // Default Ship Geometry
        const createShip = () => {
            const hull = new THREE.Mesh(new THREE.ConeGeometry(1, 5, 4), defaultMat);
            hull.rotation.x = Math.PI/2;
            hull.rotation.y = Math.PI/4;
            
            const wings = new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 2), defaultMat);
            wings.position.z = 1;
            
            playerShip = new THREE.Group();
            playerShip.add(hull);
            playerShip.add(wings);
            playerGroup.add(playerShip);
        };
        createShip();

        // --- GAME LOGIC ARRAYS ---
        const projectiles = [];
        const enemies = [];
        const particles = [];

        // --- INPUT & PHYSICS VARIABLES ---
        const keys = { w:false, a:false, s:false, d:false, shift:false };
        const velocity = { thrust: 0, pitch: 0, yaw: 0, roll: 0 }; // Current momentum
        
        window.addEventListener('keydown', e => {
            if(keys[e.key.toLowerCase()] !== undefined) keys[e.key.toLowerCase()] = true;
            if(e.key === 'Shift') keys.shift = true;
        });
        window.addEventListener('keyup', e => {
            if(keys[e.key.toLowerCase()] !== undefined) keys[e.key.toLowerCase()] = false;
            if(e.key === 'Shift') keys.shift = false;
        });

        window.addEventListener('mousedown', fireLaser);

        // --- SHOOTING ---
        const laserGeo = new THREE.BoxGeometry(0.3, 0.3, 8);
        const laserMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

        function fireLaser() {
            if(gameState.gameOver) return;
            
            // Create 2 lasers
            [-1.5, 1.5].forEach(offset => {
                const laser = new THREE.Mesh(laserGeo, laserMat);
                const pos = new THREE.Vector3(offset, 0, -2).applyMatrix4(playerGroup.matrixWorld);
                laser.position.copy(pos);
                laser.quaternion.copy(playerGroup.quaternion);
                scene.add(laser);
                projectiles.push({ mesh: laser, life: 80 });
            });
            
            // Recoil visual
            playerShip.position.z += 0.4;
        }

        // --- PARTICLES ---
        function explode(pos, color) {
            for(let i=0; i<8; i++) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color: color}));
                mesh.position.copy(pos);
                scene.add(mesh);
                particles.push({ 
                    mesh: mesh, 
                    vel: new THREE.Vector3((Math.random()-.5)*20, (Math.random()-.5)*20, (Math.random()-.5)*20),
                    life: 40 
                });
            }
        }

        // --- MAIN LOOP ---
        const gameState = { score: 0, combo: 1, lastKill: 0, hp: 100, gameOver: false };
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if(gameState.gameOver) return;

            // --- 1. SMOOTH PHYSICS CONTROLS ---
            
            // Target rotation speeds based on input
            const targetPitch = (keys.w ? 1 : 0) - (keys.s ? 1 : 0); // W = Pitch Up (Positive X rotation for Group)
            const targetYaw = (keys.a ? 1 : 0) - (keys.d ? 1 : 0);   // A = Turn Left (Positive Y rotation)
            
            // Apply "Inertia" (Lerp towards target)
            velocity.pitch += (targetPitch * SETTINGS.pitchSpeed - velocity.pitch) * (1 - SETTINGS.inertia);
            velocity.yaw += (targetYaw * SETTINGS.turnSpeed - velocity.yaw) * (1 - SETTINGS.inertia);
            
            // Apply Rotation
            playerGroup.rotateX(velocity.pitch * delta);
            playerGroup.rotateY(velocity.yaw * delta);

            // Visual "Banking" (Roll the ship model, not the group)
            // If we are turning Left (Yaw +), we bank Left (Roll +Z)
            const targetBank = velocity.yaw * 0.5; 
            playerShip.rotation.z = THREE.MathUtils.lerp(playerShip.rotation.z, targetBank, 0.1);

            // Thrust Speed
            const targetThrust = keys.shift ? 100 : 40;
            velocity.thrust += (targetThrust - velocity.thrust) * 0.05; // Smooth acceleration
            playerGroup.translateZ(-velocity.thrust * delta);

            // Keep Floor/Ceiling Grids centered on X/Z but locked on Y
            floorGrid.position.x = playerGroup.position.x;
            floorGrid.position.z = playerGroup.position.z;
            ceilingGrid.position.x = playerGroup.position.x;
            ceilingGrid.position.z = playerGroup.position.z;

            // Recoil recovery
            if(playerShip.position.z > 0) playerShip.position.z -= 5 * delta;


            // --- 2. ARTIFICIAL HORIZON HUD ---
            // We need the ship's roll (Z rotation) relative to the world
            // This is a bit of math trickery to extract Roll from the Group quaternion
            const euler = new THREE.Euler().setFromQuaternion(playerGroup.quaternion, 'YXZ');
            // Rotate the HTML line opposite to the ship's roll to keep it "level"
            const rollDeg = -THREE.MathUtils.radToDeg(euler.z);
            const pitchDeg = THREE.MathUtils.radToDeg(euler.x);
            
            const horizonLine = document.getElementById('horizon-line');
            horizonLine.style.transform = `rotate(${rollDeg}deg) translateY(${pitchDeg * 2}px)`;


            // --- 3. CAMERA CHASE ---
            const camTarget = new THREE.Vector3(0, 6 + (velocity.thrust/30), 15 + (velocity.thrust/10));
            camTarget.applyMatrix4(playerGroup.matrixWorld);
            camera.position.lerp(camTarget, 0.1);
            camera.lookAt(playerGroup.position.clone().translateZ(-50)); // Look slightly ahead


            // --- 4. PROJECTILES ---
            projectiles.forEach((p, i) => {
                p.mesh.translateZ(-300 * delta); // Fast lasers
                p.life--;
                if(p.life <= 0) { scene.remove(p.mesh); projectiles.splice(i,1); }
            });


            // --- 5. ENEMIES ---
            const spawnRate = 0.02 + (time * 0.0005); // Get harder over time
            if(Math.random() < spawnRate && enemies.length < 20) {
                const geo = new THREE.IcosahedronGeometry(2, 0);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff0055, wireframe: true });
                const enemy = new THREE.Mesh(geo, mat);
                
                // Spawn ahead
                const spawnPos = new THREE.Vector3(
                    (Math.random()-0.5)*300,
                    (Math.random()-0.5)*100,
                    -300 - (Math.random()*200)
                );
                spawnPos.applyMatrix4(playerGroup.matrixWorld);
                enemy.position.copy(spawnPos);
                scene.add(enemy);
                enemies.push(enemy);
            }

            enemies.forEach((e, i) => {
                // Move towards player
                const dir = new THREE.Vector3().subVectors(playerGroup.position, e.position).normalize();
                e.position.add(dir.multiplyScalar(25 * delta));
                e.rotation.x += delta; e.rotation.y += delta;

                // Collision: Laser
                let hit = false;
                projectiles.forEach((p, pi) => {
                    if(p.mesh.position.distanceTo(e.position) < 5) {
                        hit = true;
                        scene.remove(p.mesh); projectiles.splice(pi,1);
                    }
                });

                // Collision: Player
                if(e.position.distanceTo(playerGroup.position) < 5) {
                    takeDamage(20);
                    hit = true;
                }

                if(hit) {
                    explode(e.position, 0xff0055);
                    scene.remove(e); enemies.splice(i,1);
                    if(e.position.distanceTo(playerGroup.position) > 5) addScore();
                }
            });

            // --- 6. PARTICLES ---
            particles.forEach((p, i) => {
                p.mesh.position.add(p.vel.clone().multiplyScalar(delta));
                p.life--;
                p.mesh.scale.multiplyScalar(0.95);
                if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i,1); }
            });
            
            // Combo timer
            if(time - gameState.lastKill > 3 && gameState.combo > 1) {
                gameState.combo = 1;
                updateHUD();
            }

            renderer.render(scene, camera);
        }

        // --- HELPERS ---
        function takeDamage(amt) {
            gameState.hp -= amt;
            updateHUD();
            const flash = document.getElementById('flash');
            flash.style.opacity = 0.8;
            setTimeout(() => flash.style.opacity = 0, 100);
            
            if(gameState.hp <= 0) {
                gameState.gameOver = true;
                document.querySelector('.hud-bottom').innerHTML = "<h1 style='color:red'>SYSTEM FAILURE // REFRESH TO REBOOT</h1>";
            }
        }

        function addScore() {
            gameState.score += 100 * gameState.combo;
            if(gameState.combo < 10) gameState.combo++;
            gameState.lastKill = clock.getElapsedTime();
            updateHUD();
        }

        function updateHUD() {
            document.getElementById('score').innerText = gameState.score.toLocaleString();
            document.getElementById('combo').innerText = gameState.combo;
            const bar = document.getElementById('hp-bar');
            bar.style.width = gameState.hp + '%';
            if(gameState.hp < 30) bar.style.backgroundColor = 'red';
        }

        // --- UPLOAD ---
        const loader = new GLTFLoader();
        document.getElementById('fileInput').addEventListener('change', e => {
            const file = e.target.files[0];
            if(!file) return;
            const url = URL.createObjectURL(file);
            
            if(file.name.match(/\.(glb|gltf)$/i)) {
                loader.load(url, gltf => {
                    playerShip.clear(); // Clear old
                    const model = gltf.scene;
                    // Scale normalization
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    model.scale.setScalar(4 / Math.max(size.x, size.y, size.z));
                    model.rotation.y = Math.PI;
                    playerShip.add(model);
                });
            } else if(file.name.match(/\.(png|jpg)$/i)) {
                new THREE.TextureLoader().load(url, tex => {
                    playerShip.clear();
                    const aspect = tex.image.height/tex.image.width;
                    const plane = new THREE.Mesh(
                        new THREE.PlaneGeometry(4, 4*aspect),
                        new THREE.MeshBasicMaterial({ map:tex, transparent:true, side:THREE.DoubleSide })
                    );
                    plane.rotation.x = -Math.PI/2;
                    plane.rotation.y = Math.PI;
                    playerShip.add(plane);
                });
            }
        });

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
