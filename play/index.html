<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NEON VANGUARD // SURVIVAL</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        canvas { display: block; }

        /* --- HUD LAYOUT --- */
        #ui-layer {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Top Bar */
        .hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .score-box {
            color: #00ffff; text-shadow: 0 0 10px #00ffff;
            text-align: right;
        }
        .big-score { font-size: 32px; font-weight: 900; letter-spacing: 2px; }
        .multiplier { font-size: 18px; color: #ff0055; font-weight: bold; }

        .health-box {
            color: #00ff00; text-shadow: 0 0 10px #00ff00;
            font-size: 20px; font-weight: bold;
        }
        .hp-bar {
            width: 200px; height: 10px; background: #003300;
            border: 1px solid #00ff00; margin-top: 5px; skewX: -10deg;
        }
        .hp-fill { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s; }

        /* Center Reticle */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: #ff0055;
            transform: translate(-50%, -50%);
        }

        /* Bottom Bar */
        .hud-bottom {
            padding: 20px; text-align: center;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            color: white; font-size: 12px; opacity: 0.6;
        }
        
        /* Upload Button */
        .upload-zone { pointer-events: auto; margin-top: 10px; }
        .btn-upload {
            background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff;
            color: #00ffff; padding: 5px 15px; cursor: pointer; font-size: 10px;
            transition: 0.2s;
        }
        .btn-upload:hover { background: #00ffff; color: #000; }
        input[type="file"] { display: none; }

        /* Hit Flash Effect */
        #damage-overlay {
            position: absolute; inset: 0; background: red; opacity: 0;
            transition: opacity 0.1s; mix-blend-mode: overlay;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="ui-layer">
        <div class="hud-top">
            <div class="health-box">
                SHIELD INTEGRITY
                <div class="hp-bar"><div id="hp-fill" class="hp-fill"></div></div>
                <div class="upload-zone">
                    <label class="btn-upload">
                        UPLOAD CUSTOM SHIP
                        <input type="file" id="fileInput" accept=".glb,.gltf,.png,.jpg">
                    </label>
                </div>
            </div>
            <div class="score-box">
                <div class="big-score" id="score">0</div>
                <div class="multiplier">x<span id="mult">1</span> COMBO</div>
            </div>
        </div>
        
        <div id="crosshair"></div>

        <div class="hud-bottom">
            WASD: PILOT | SHIFT: BOOST | CLICK: DUAL BLASTERS<br>
            DEFEND THE SECTOR
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- GAME STATE ---
        const state = {
            score: 0,
            multiplier: 1,
            lastKillTime: 0,
            health: 100,
            isGameOver: false,
            time: 0
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.0015);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Activate bloom-like glow via tone mapping trick
        renderer.toneMapping = THREE.ReinhardToneMapping; 
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambient = new THREE.AmbientLight(0x404040);
        scene.add(ambient);
        
        // A sun that creates dramatic shadows
        const sun = new THREE.DirectionalLight(0xffffff, 2);
        sun.position.set(100, 500, 200);
        scene.add(sun);

        // Cyberpunk environment lights
        const blueLight = new THREE.PointLight(0x0088ff, 5, 300);
        blueLight.position.set(-100, 0, 0);
        scene.add(blueLight);
        const pinkLight = new THREE.PointLight(0xff0055, 5, 300);
        pinkLight.position.set(100, 0, 0);
        scene.add(pinkLight);

        // --- ENVIRONMENT: INFINITE GRID & STARS ---
        // Infinite Grid floor (gives sense of speed)
        const gridHelper = new THREE.GridHelper(2000, 100, 0x00ffff, 0x222222);
        gridHelper.position.y = -50;
        scene.add(gridHelper);

        // Starfield
        const starsGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<6000; i++) {
            starPos.push((Math.random()-0.5)*4000, (Math.random()-0.5)*4000, (Math.random()-0.5)*4000);
        }
        starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({color:0xffffff, size: 0.7}));
        scene.add(stars);

        // --- PLAYER ---
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);
        let playerShip;

        // Default Ship (Low poly fighter)
        const createDefaultShip = () => {
            const geo = new THREE.ConeGeometry(1, 4, 4);
            geo.rotateX(Math.PI/2);
            geo.rotateY(Math.PI/4); // Make it look more like a fighter
            const mat = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0x00ffff, emissiveIntensity: 0.5, roughness: 0.2, metalness: 0.8 });
            playerShip = new THREE.Mesh(geo, mat);
            // Wings
            const wingGeo = new THREE.BoxGeometry(4, 0.1, 2);
            const wing = new THREE.Mesh(wingGeo, mat);
            wing.position.z = 1;
            playerShip.add(wing);
            playerGroup.add(playerShip);
        };
        createDefaultShip();

        // --- OBJECT POOLS & SYSTEMS ---
        const projectiles = [];
        const enemies = [];
        const particles = [];

        // GEOMETRIES MATERIALS
        const laserGeo = new THREE.BoxGeometry(0.2, 0.2, 6);
        const laserMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        
        const enemyGeo = new THREE.IcosahedronGeometry(1.5, 0);
        const enemyMat = new THREE.MeshBasicMaterial({ color: 0xff0055, wireframe: true });
        const enemyCoreMat = new THREE.MeshBasicMaterial({ color: 0x550000 });

        // --- INPUT SYSTEM ---
        const keys = { w:false, a:false, s:false, d:false, shift:false };
        window.addEventListener('keydown', e => { if(keys[e.key.toLowerCase()] !== undefined) keys[e.key.toLowerCase()] = true; if(e.key === 'Shift') keys.shift = true; });
        window.addEventListener('keyup', e => { if(keys[e.key.toLowerCase()] !== undefined) keys[e.key.toLowerCase()] = false; if(e.key === 'Shift') keys.shift = false; });

        // Mouse Shooting
        window.addEventListener('mousedown', () => fireLasers());

        function fireLasers() {
            if(state.isGameOver) return;
            
            // Dual Blasters
            const offsets = [-1.5, 1.5];
            offsets.forEach(xOffset => {
                const laser = new THREE.Mesh(laserGeo, laserMat);
                
                // Position relative to ship
                const pos = new THREE.Vector3(xOffset, 0, -2);
                pos.applyMatrix4(playerGroup.matrixWorld);
                laser.position.copy(pos);
                laser.quaternion.copy(playerGroup.quaternion);
                
                scene.add(laser);
                projectiles.push({ mesh: laser, velocity: 200, life: 60 });
            });

            // Audio feedback visual (recoil)
            playerShip.position.z += 0.5;
        }

        function spawnExplosion(pos) {
            const color = new THREE.Color(0xff0055);
            for(let i=0; i<12; i++) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshBasicMaterial({color: color}));
                mesh.position.copy(pos);
                // Random velocity
                const vel = new THREE.Vector3((Math.random()-.5)*20, (Math.random()-.5)*20, (Math.random()-.5)*20);
                scene.add(mesh);
                particles.push({ mesh: mesh, velocity: vel, life: 30, decay: true });
            }
        }

        // --- MAIN LOOP ---
        const clock = new THREE.Clock();
        
        // Camera Chase Stats
        const camOffset = new THREE.Vector3(0, 6, 15);
        let currentSpeed = 0;
        let shake = 0;

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const now = clock.getElapsedTime();
            state.time += delta;

            if(state.isGameOver) return;

            // 1. MOVEMENT PHYSICS
            const pitchSpeed = 1.5;
            const turnSpeed = 2.0;
            
            if(keys.w) playerGroup.rotateX(pitchSpeed * delta);
            if(keys.s) playerGroup.rotateX(-pitchSpeed * delta);
            if(keys.a) playerGroup.rotateY(turnSpeed * delta);
            if(keys.d) playerGroup.rotateY(-turnSpeed * delta);

            // Forward Thrust
            const targetSpeed = keys.shift ? 80 : 30;
            currentSpeed += (targetSpeed - currentSpeed) * 2 * delta;
            playerGroup.translateZ(-currentSpeed * delta); // Move forward (Negative Z)

            // Recoil Recovery
            if(playerShip && playerShip.position.z > 0) playerShip.position.z -= 5 * delta;

            // 2. CAMERA LOGIC
            // Calculate ideal camera position
            const idealPos = new THREE.Vector3(0, 5 + (currentSpeed/20), 12 + (currentSpeed/10));
            idealPos.applyMatrix4(playerGroup.matrixWorld);
            
            // Add shake
            if(shake > 0) {
                idealPos.x += (Math.random()-.5) * shake;
                idealPos.y += (Math.random()-.5) * shake;
                shake -= delta * 2;
            }

            camera.position.lerp(idealPos, 0.1);
            camera.lookAt(playerGroup.position.clone().add(new THREE.Vector3(0,0,-20).applyQuaternion(playerGroup.quaternion)));

            // 3. PROJECTILES
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.mesh.translateZ(-p.velocity * delta); // Lasers fly forward relative to rotation
                p.life--;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }

            // 4. ENEMY SPAWNER
            // Difficulty ramps up over time
            const maxEnemies = 5 + Math.floor(state.time / 10);
            if(enemies.length < maxEnemies && Math.random() < 0.05) {
                const enemy = new THREE.Group();
                
                // Wireframe outer
                const shell = new THREE.Mesh(enemyGeo, enemyMat.clone());
                // Solid inner
                const core = new THREE.Mesh(new THREE.IcosahedronGeometry(0.5), enemyCoreMat);
                
                enemy.add(shell);
                enemy.add(core);
                
                // Spawn somewhere ahead of player
                const spawnDist = 200;
                const angle = Math.random() * Math.PI * 2;
                // Random position in sphere around player
                const offset = new THREE.Vector3(
                    (Math.random()-.5)*200,
                    (Math.random()-.5)*200,
                    -200 - Math.random()*100
                );
                offset.applyQuaternion(playerGroup.quaternion);
                enemy.position.copy(playerGroup.position).add(offset);
                
                scene.add(enemy);
                enemies.push({ group: enemy, speed: 15 + Math.random()*10, rot: Math.random() });
            }

            // 5. ENEMY LOGIC (CHASE)
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                
                // Rotate enemy for visual flair
                e.group.rotation.x += delta;
                e.group.rotation.y += delta;

                // Move towards player
                const toPlayer = new THREE.Vector3().subVectors(playerGroup.position, e.group.position);
                const dist = toPlayer.length();
                toPlayer.normalize();
                
                e.group.position.add(toPlayer.multiplyScalar(e.speed * delta));

                // Player Collision (Damage)
                if(dist < 5) {
                    spawnExplosion(e.group.position);
                    scene.remove(e.group);
                    enemies.splice(i, 1);
                    takeDamage(15);
                    continue;
                }

                // Laser Collision
                let hit = false;
                for(let j = projectiles.length - 1; j >= 0; j--) {
                    const proj = projectiles[j];
                    if(proj.mesh.position.distanceTo(e.group.position) < 4) {
                        // HIT!
                        hit = true;
                        spawnExplosion(e.group.position);
                        
                        // Remove laser
                        scene.remove(proj.mesh);
                        projectiles.splice(j, 1);
                        break;
                    }
                }

                if(hit) {
                    scene.remove(e.group);
                    enemies.splice(i, 1);
                    addScore();
                }
            }

            // 6. PARTICLES
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.velocity.clone().multiplyScalar(delta));
                p.life--;
                p.mesh.rotation.x += delta * 5;
                if(p.decay) {
                   p.mesh.scale.multiplyScalar(0.9);
                }
                if(p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i,1);
                }
            }

            // 7. TRAIL EFFECT
            if(state.time % 0.05 < 0.01) {
                const tGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const tMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
                const trail = new THREE.Mesh(tGeo, tMat);
                trail.position.copy(playerGroup.position);
                // Push back slightly
                trail.translateZ(2);
                scene.add(trail);
                particles.push({ mesh: trail, velocity: new THREE.Vector3(0,0,0), life: 20, decay: true });
            }
            
            // Combo Decay
            if(now - state.lastKillTime > 3) {
                state.multiplier = 1;
                updateHUD();
            }

            renderer.render(scene, camera);
        }

        // --- GAME LOGIC ---
        function takeDamage(amt) {
            state.health -= amt;
            shake = 2.0; // Screen shake
            
            // Red flash
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.8;
            setTimeout(() => overlay.style.opacity = 0, 100);

            if(state.health <= 0) {
                state.health = 0;
                state.isGameOver = true;
                document.querySelector('.hud-bottom').innerHTML = `<span style="font-size:30px; color:red">MISSION FAILED</span><br>RELOAD TO RESTART`;
            }
            updateHUD();
        }

        function addScore() {
            state.score += 100 * state.multiplier;
            state.multiplier++;
            if(state.multiplier > 10) state.multiplier = 10; // Cap combo
            state.lastKillTime = clock.getElapsedTime();
            updateHUD();
        }

        function updateHUD() {
            document.getElementById('score').innerText = state.score.toLocaleString();
            document.getElementById('mult').innerText = state.multiplier;
            document.getElementById('hp-fill').style.width = state.health + '%';
            
            // Color change on low health
            if(state.health < 30) document.getElementById('hp-fill').style.backgroundColor = 'red';
        }

        // --- UPLOAD HANDLER ---
        const gltfLoader = new GLTFLoader();
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const url = URL.createObjectURL(file);
            
            if(file.name.match(/\.(glb|gltf)$/i)) {
                gltfLoader.load(url, (gltf) => {
                    playerGroup.remove(playerShip);
                    playerShip = gltf.scene;
                    const box = new THREE.Box3().setFromObject(playerShip);
                    const size = box.getSize(new THREE.Vector3());
                    playerShip.scale.setScalar(4 / Math.max(size.x, size.y, size.z));
                    playerShip.rotation.y = Math.PI; 
                    playerGroup.add(playerShip);
                });
            } else if(file.name.match(/\.(png|jpg|jpeg)$/i)) {
                new THREE.TextureLoader().load(url, (tex) => {
                    playerGroup.remove(playerShip);
                    const aspect = tex.image.height/tex.image.width;
                    playerShip = new THREE.Mesh(
                        new THREE.PlaneGeometry(4, 4*aspect),
                        new THREE.MeshBasicMaterial({ map:tex, transparent:true, side:THREE.DoubleSide })
                    );
                    playerShip.rotation.x = -Math.PI/2;
                    playerShip.rotation.y = Math.PI;
                    playerGroup.add(playerShip);
                });
            }
        });

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
