<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ORBITAL: ROLLING EARTH</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', monospace; user-select: none; }
        canvas { display: block; }

        /* --- HUD UI --- */
        #ui-layer {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Top HUD */
        .hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        .stat-box { color: #00ffff; text-shadow: 0 0 10px #00ffff; }
        .big-text { font-size: 24px; font-weight: 900; letter-spacing: 2px; }
        .sub-text { font-size: 12px; font-weight: bold; opacity: 0.8; }

        /* Artificial Horizon */
        #horizon-wrapper {
            position: absolute; top: 50%; left: 50%;
            width: 300px; height: 300px;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 255, 0.3);
            overflow: hidden; opacity: 0.8;
        }
        #horizon-line {
            position: absolute; top: 50%; left: -50%; right: -50%;
            height: 2px; background: #00ffff; box-shadow: 0 0 8px #00ffff;
        }
        #center-point {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: #ff0055; transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #ff0055;
        }

        /* Bottom HUD */
        .hud-bottom {
            padding: 20px; text-align: center;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            color: #88aaff; font-size: 11px;
        }

        /* Controls */
        .upload-btn {
            pointer-events: auto; background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff; color: #00ffff; padding: 5px 10px;
            cursor: pointer; font-size: 10px; margin-top: 5px; display: inline-block;
        }
        input[type="file"] { display: none; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-box">
                <div class="sub-text">ORBITAL SPEED</div>
                <div class="big-text"><span id="speed-val">0</span> KM/H</div>
            </div>
            <div class="stat-box" style="text-align:right;">
                <div class="sub-text">VESSEL CONFIG</div>
                <label class="upload-btn">
                    UPLOAD SHIP
                    <input type="file" id="fileInput" accept=".glb,.gltf,.png,.jpg">
                </label>
            </div>
        </div>

        <div id="horizon-wrapper">
            <div id="horizon-line"></div>
        </div>
        <div id="center-point"></div>

        <div class="hud-bottom">
            WASD: Pitch & Roll | SHIFT: Increase Orbit Speed
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- CONFIGURATION ---
        const EARTH_RADIUS = 600;
        const ORBIT_HEIGHT = 620; // Player sits at 20 units above surface
        
        // --- SCENE ---
        const scene = new THREE.Scene();
        // Set a dark blue background so you KNOW it's working even if earth is black
        scene.background = new THREE.Color(0x000510); 
        scene.fog = new THREE.FogExp2(0x000510, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
        // Position camera slightly behind and above the "Player" point
        camera.position.set(0, ORBIT_HEIGHT + 5, 20); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING (Critical for avoiding black screen) ---
        // 1. Ambient Light (Guarantees everything is at least dimly visible)
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        // 2. Sun Light (Directional)
        const sun = new THREE.DirectionalLight(0xffffff, 2.0);
        sun.position.set(500, 500, 500);
        scene.add(sun);

        // --- THE GIANT EARTH SPHERE ---
        const earthGroup = new THREE.Group();
        // Move the earth DOWN so the top of it touches our orbit line
        earthGroup.position.y = -EARTH_RADIUS + (ORBIT_HEIGHT - 620); 
        scene.add(earthGroup);

        const textureLoader = new THREE.TextureLoader();
        // High-res Earth texture
        const earthUrl = 'https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg';
        
        const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS, 128, 128);
        const earthMat = new THREE.MeshPhongMaterial({
            color: 0xffffff, // White base to let texture show
            emissive: 0x112244, // Slight glow so it's never fully black
            specular: 0x333333,
            shininess: 15
        });
        
        // Try to load texture, but if it fails, we still have the blue material above
        textureLoader.load(earthUrl, (tex) => {
            earthMat.map = tex;
            earthMat.needsUpdate = true;
        }, undefined, (err) => {
            console.log("Texture failed to load (CORS?), using blue material.");
            earthMat.color.setHex(0x0044ff);
            earthMat.wireframe = true; // Cool fallback style
        });

        const earth = new THREE.Mesh(earthGeo, earthMat);
        // Rotate earth initially so we aren't looking at a pole
        earth.rotation.x = 0.5; 
        earthGroup.add(earth);

        // Atmosphere Halo
        const atmos = new THREE.Mesh(
            new THREE.SphereGeometry(EARTH_RADIUS * 1.02, 64, 64),
            new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.1, side: THREE.BackSide })
        );
        earthGroup.add(atmos);

        // --- STARS ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<5000; i++) {
            const x = (Math.random()-0.5) * 4000;
            const y = (Math.random()-0.5) * 4000; // Keep stars high
            const z = (Math.random()-0.5) * 4000;
            // Keep stars away from earth center
            if(y > -500) starPos.push(x,y,z); 
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size: 1.5}));
        scene.add(stars);


        // --- PLAYER SHIP ---
        const playerGroup = new THREE.Group();
        playerGroup.position.set(0, ORBIT_HEIGHT, 0);
        scene.add(playerGroup);

        let playerShip;
        const defaultShipMat = new THREE.MeshStandardMaterial({ color: 0x333333, emissive: 0x00ffff, emissiveIntensity: 0.5 });
        
        function createShip() {
            // Simple Fighter Shape
            const body = new THREE.Mesh(new THREE.ConeGeometry(1, 5, 4), defaultShipMat);
            body.rotation.x = Math.PI/2;
            const wings = new THREE.Mesh(new THREE.BoxGeometry(6, 0.2, 2), defaultShipMat);
            wings.position.z = 1;
            
            playerShip = new THREE.Group();
            playerShip.add(body);
            playerShip.add(wings);
            playerGroup.add(playerShip);
        }
        createShip();


        // --- INPUT & LOGIC ---
        const keys = { w:false, a:false, s:false, d:false, shift:false };
        const state = { pitch: 0, yaw: 0, roll: 0, speed: 0.0005 };

        window.addEventListener('keydown', e => {
            if(keys[e.key.toLowerCase()] !== undefined) keys[e.key.toLowerCase()] = true;
            if(e.key === 'Shift') keys.shift = true;
        });
        window.addEventListener('keyup', e => {
            if(keys[e.key.toLowerCase()] !== undefined) keys[e.key.toLowerCase()] = false;
            if(e.key === 'Shift') keys.shift = false;
        });


        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // 1. ROLL THE EARTH (Simulate Speed)
            // The earth rotates on X axis to simulate us flying North/South
            // Base speed + Boost
            const targetSpeed = keys.shift ? 0.004 : 0.0005;
            state.speed += (targetSpeed - state.speed) * 0.05;
            
            earth.rotation.x -= state.speed; 

            // 2. SHIP MOVEMENT (Local rotation only)
            const pitchInput = (keys.w ? 1 : 0) - (keys.s ? 1 : 0);
            const yawInput = (keys.a ? 1 : 0) - (keys.d ? 1 : 0);

            // Inertia logic
            state.pitch += (pitchInput * 0.8 - state.pitch) * 0.1;
            state.yaw += (yawInput * 0.8 - state.yaw) * 0.1;
            state.roll = -state.yaw * 0.5; // Bank into the turn

            // Apply rotation to player group
            playerGroup.rotation.x = state.pitch * 0.5;
            playerGroup.rotation.z = state.roll;
            playerGroup.rotation.y = state.yaw * 0.3;

            // Move Stars slowly to match earth speed (Parallax)
            stars.rotation.x += state.speed * 0.1;


            // 3. CAMERA CHASE
            // Camera is slightly lazy
            const camIdeal = new THREE.Vector3(0, 6, 15);
            camIdeal.applyMatrix4(playerGroup.matrixWorld);
            camera.position.lerp(camIdeal, 0.1);
            camera.lookAt(playerGroup.position.clone().translateZ(-100));


            // 4. HUD UPDATE
            // Update Artificial Horizon
            // We use the Player Group's Z rotation (Roll) and X rotation (Pitch)
            const rollDeg = -THREE.MathUtils.radToDeg(playerGroup.rotation.z);
            const pitchDeg = THREE.MathUtils.radToDeg(playerGroup.rotation.x);
            
            const horizon = document.getElementById('horizon-line');
            horizon.style.transform = `rotate(${rollDeg}deg) translateY(${pitchDeg * 5}px)`;

            // Update Speed Text
            document.getElementById('speed-val').innerText = Math.floor(state.speed * 1000000);

            renderer.render(scene, camera);
        }
        animate();

        // --- UPLOAD HANDLING ---
        const loader = new GLTFLoader();
        document.getElementById('fileInput').addEventListener('change', e => {
            const file = e.target.files[0];
            if(!file) return;
            const url = URL.createObjectURL(file);
            if(file.name.match(/\.(glb|gltf)$/i)) {
                loader.load(url, gltf => {
                    if(playerShip) playerGroup.remove(playerShip);
                    playerShip = gltf.scene;
                    // Auto-scale
                    const box = new THREE.Box3().setFromObject(playerShip);
                    const size = box.getSize(new THREE.Vector3());
                    playerShip.scale.setScalar(5 / Math.max(size.x, size.y, size.z));
                    playerShip.rotation.y = Math.PI;
                    playerGroup.add(playerShip);
                });
            } else if(file.name.match(/\.(png|jpg)$/i)) {
                new THREE.TextureLoader().load(url, tex => {
                    if(playerShip) playerGroup.remove(playerShip);
                    const aspect = tex.image.height/tex.image.width;
                    const mesh = new THREE.Mesh(
                        new THREE.PlaneGeometry(5, 5*aspect),
                        new THREE.MeshBasicMaterial({map:tex, transparent:true, side:THREE.DoubleSide})
                    );
                    mesh.rotation.x = -Math.PI/2; mesh.rotation.y = Math.PI;
                    playerShip = new THREE.Mesh().add(mesh); // Wrap in group
                    playerGroup.add(playerShip);
                });
            }
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
