<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
<title>Cybernetic Node v4.0 - Mobile</title>
<style>
  body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#000; color:#0f0; font-family:'Orbitron', monospace; }

  /* MAIN */
  #mainContent { display:block; position:relative; height:100%; width:100%; }

  #matrixCanvas, #particleCanvas { position:absolute; top:0; left:0; width:100%; height:100%; }
  #matrixCanvas { z-index:0; opacity:0.12; pointer-events:none; }
  #particleCanvas { z-index:1; pointer-events:none; }

  /* ensure avatar sits above the animated text */
  #avatarContainer {
    position:absolute; top:6%; left:50%; transform:translateX(-50%);
    z-index:4; opacity:0; transition:opacity 1.2s ease-in-out;
  }
  #avatarImg {
    width:180px; height:180px; border-radius:50%;
    border:3px solid #00ff88; box-shadow:0 0 20px #00ff88, inset 0 0 10px rgba(0,255,0,0.3);
    transition:all .4s;
  }
  #avatarContainer:hover #avatarImg { transform:scale(1.05); box-shadow:0 0 30px #00ffaa, 0 0 50px rgba(0,255,200,.5); }

  /* displayText positioned below the avatar; z-index lower so avatar is always on top */
  #displayText {
    position:absolute; left:50%; transform:translateX(-50%);
    color:#00ff88; font-size:1em; white-space:pre-line; z-index:3; text-align:center; padding:0 10px;
  }

  #terminal {
    position:absolute; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,0.85); border:1px solid #0f0; padding:8px 10px;
    width:92%; max-width:420px; color:#0f0; font-family:monospace; font-size:13px;
    display:none; z-index:7; border-radius:8px;
  }
  #terminalOutput { max-height:120px; overflow-y:auto; margin-bottom:5px; }
  #terminalInput { width:95%; background:#000; color:#0f0; border:none; outline:none; }

  /* CRYPTO - make compact and scrollable on narrow screens so it doesn't take too much height */
  .crypto-dashboard-wrapper {
    position:absolute; bottom:3%; left:50%; transform:translateX(-50%);
    z-index:5; width:95%; max-width:900px;
  }
  .crypto-dashboard-container {
    display:flex; gap:12px; justify-content:flex-start; align-items:center;
    overflow-x:auto; padding:6px 4px; box-sizing:border-box;
    font-family:'Orbitron', sans-serif;
  }
  .crypto-card {
    background:rgba(0,0,0,0.6); border:2px solid #00ffea; border-radius:12px;
    padding:8px 10px; flex:0 0 120px; min-width:110px; height:64px; text-align:center; color:#00ffea;
    box-shadow:0 0 12px #00ffea; transition:.2s; display:flex; flex-direction:column; justify-content:center;
  }
  .crypto-card:hover { box-shadow:0 0 25px #ff00ff; transform:translateY(-3px); }
  .crypto-card h2 { margin:0; font-size:0.95em; letter-spacing:1px; }
  .crypto-card .price { font-size:1.1em; font-weight:bold; margin:2px 0 0 0; }

  /* MOBILE SPECIFIC */
  @media(max-width:600px){
    #avatarImg { width:150px; height:150px; }
    #displayText { font-size:0.9em; }
    #terminal { max-width:94%; font-size:12px; padding:6px 8px; }
    .crypto-card { flex:0 0 110px; min-width:100px; padding:8px; height:60px; }
    .crypto-card .price { font-size:1em; }
  }
</style>
</head>
<body>

<div id="mainContent">
  <canvas id="matrixCanvas"></canvas>
  <canvas id="particleCanvas"></canvas>

  <div id="avatarContainer">
    <img id="avatarImg" src="https://na-assets.pinit.io/8GwrpeSH4TpAGEJsmoF35J8DY6RNCdyjCBZsEnTySEKd/c746a7a7-88cc-4677-b919-877329e2dd0d/437" />
  </div>

  <div id="displayText">Initializing Neural Link...</div>

  <div id="terminal">
    <div id="terminalOutput"></div>
    <div><span>&gt; </span><input id="terminalInput" type="text" autocomplete="off"/></div>
  </div>

  <div class="crypto-dashboard-wrapper">
    <div id="crypto-dashboard" class="crypto-dashboard-container">
      <div class="crypto-card" id="btc-card"><h2>BTC</h2><p class="price">$0</p></div>
      <div class="crypto-card" id="eth-card"><h2>ETH</h2><p class="price">$0</p></div>
      <div class="crypto-card" id="sol-card"><h2>SOL</h2><p class="price">$0</p></div>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const displayText = document.getElementById('displayText');
  const avatarContainer = document.getElementById('avatarContainer');
  const avatarImg = document.getElementById('avatarImg');
  const terminal = document.getElementById('terminal');
  const terminalInput = document.getElementById('terminalInput');
  const terminalOutput = document.getElementById('terminalOutput');
  const matrixCanvas = document.getElementById('matrixCanvas');
  const mctx = matrixCanvas.getContext('2d');
  const particleCanvas = document.getElementById('particleCanvas');
  const pctx = particleCanvas.getContext('2d');
  const cryptoWrapper = document.querySelector('.crypto-dashboard-wrapper');

  let username = "Echo"; // default username

  const chars = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';

  let fontSize = window.innerWidth < 600 ? 10 : 14;
  let columns = Math.floor(window.innerWidth / fontSize);
  let drops = Array(columns).fill(1);

  function resize() {
    matrixCanvas.width = particleCanvas.width = window.innerWidth;
    matrixCanvas.height = particleCanvas.height = window.innerHeight;
    fontSize = window.innerWidth < 600 ? 10 : 14;
    columns = Math.floor(matrixCanvas.width / fontSize);
    drops = Array(columns).fill(1);

    // reposition displayText below avatar and keep terminal above crypto area
    positionDisplayText();
    positionTerminal();
  }
  window.addEventListener('resize', resize);
  resize();

  function positionDisplayText(){
    // place displayText just below avatar container to avoid overlap
    try {
      const avatarRectTop = avatarContainer.offsetTop;
      const avatarH = avatarImg.offsetHeight || 180;
      const gap = 10;
      const topPx = avatarRectTop + avatarH + gap;
      displayText.style.top = topPx + 'px';
    } catch (e) {
      // fallback
      displayText.style.top = 'calc(6% + 190px)';
    }
  }

  function positionTerminal(){
    // ensure terminal sits above the crypto dashboard so it won't cover it
    try {
      const cryptoH = cryptoWrapper.offsetHeight || 80;
      const gap = 18;
      terminal.style.bottom = (cryptoH + gap) + 'px';
    } catch (e) {
      terminal.style.bottom = '18%';
    }
  }

  function bootSequence() {
    const messages = [`User ${username} recognized...`, "Decrypting neural matrix...", "Stabilizing data stream...", "Neural link established.", "Type help for more info"];
    let i=0;
    function typeNext() {
      if(i>=messages.length) {
        avatarContainer.style.opacity=1;
        terminal.style.display='block';
        terminalInput.focus();
        startMatrix();
        startParticles();
        fetchCrypto();
        setInterval(fetchCrypto,5000);

        // after avatar becomes visible, recalc positions
        setTimeout(()=>{ positionDisplayText(); positionTerminal(); }, 120);
        return;
      }
      let j=0; displayText.textContent="";
      function typer() {
        if(j<messages[i].length){ displayText.textContent+=messages[i][j++]; setTimeout(typer,30); }
        else { i++; setTimeout(typeNext,500); }
      }
      typer();
    }
    typeNext();
  }
  bootSequence();

  function startMatrix() {
    function drawMatrix() {
      mctx.fillStyle='rgba(0,0,0,0.07)'; mctx.fillRect(0,0,matrixCanvas.width,matrixCanvas.height);
      mctx.fillStyle='#00ff88'; mctx.shadowColor='#00ff88'; mctx.shadowBlur=8;
      mctx.font=fontSize+"px monospace";
      for(let i=0;i<drops.length;i++){
        const text=chars[Math.floor(Math.random()*chars.length)];
        mctx.fillText(text,i*fontSize,drops[i]*fontSize);
        if(drops[i]*fontSize>matrixCanvas.height && Math.random()>0.975) drops[i]=0;
        drops[i]++;
      }
    }
    setInterval(drawMatrix,50);
  }

  let particles=[], mouse={x:window.innerWidth/2,y:window.innerHeight/2};
  window.addEventListener('mousemove',e=>{ mouse.x=e.clientX; mouse.y=e.clientY; });
  class Particle {
    constructor(){ 
      this.x=Math.random()*particleCanvas.width; 
      this.y=Math.random()*particleCanvas.height; 
      this.size=Math.random()*2+1; 
      this.speedX=Math.random()-0.5; 
      this.speedY=Math.random()-0.5; 
    }
    update(){
      this.x += this.speedX + (mouse.x - this.x) * 0.001;
      this.y += this.speedY + (mouse.y - this.y) * 0.001;
      if(this.x < 0 || this.x > particleCanvas.width) this.speedX *= -1;
      if(this.y < 0 || this.y > particleCanvas.height) this.speedY *= -1;
    }
    draw(){ pctx.fillStyle="rgba(0,255,200,0.2)"; pctx.beginPath(); pctx.arc(this.x,this.y,this.size,0,Math.PI*2); pctx.fill(); }
  }
  function startParticles(num=window.innerWidth<600?80:180){ particles=[]; for(let i=0;i<num;i++) particles.push(new Particle()); animate(); }
  function animate(){ pctx.fillStyle="rgba(0,0,0,0.06)"; pctx.fillRect(0,0,particleCanvas.width,particleCanvas.height); particles.forEach(p=>{p.update();p.draw();}); requestAnimationFrame(animate); }

  async function fetchCrypto(){
    try{
      const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,solana&vs_currencies=usd');
      const data = await res.json();
      const formatPrice = (price) => `$${Math.floor(price).toLocaleString()}`;
      document.querySelector('#btc-card .price').textContent = formatPrice(data.bitcoin.usd);
      document.querySelector('#eth-card .price').textContent = formatPrice(data.ethereum.usd);
      document.querySelector('#sol-card .price').textContent = formatPrice(data.solana.usd);
      // if sizes change because of numbers, reposition terminal
      setTimeout(positionTerminal, 40);
    } catch {
      document.querySelectorAll('.crypto-card .price').forEach(p => p.textContent = "$Err");
    }
  }

  const commands = {
    help:()=>`Available commands: help | clear | status | scan | echo [msg] | hack | whoami | x | youtube | project89 | play`,
    clear:()=>{ terminalOutput.innerHTML=''; return ''; },
    status:()=>`Node: ACTIVE | User: ${username} | Link: SECURE | Uptime: ${Math.floor(performance.now()/1000)}s`,
    scan:()=>`Scanning neural net... [OK] Avatar Core | [OK] Quantum Relay | [OK] 127.0.0.1`,
    echo:(args)=> args.join(' '),
    hack:()=>`ACCESS GRANTED. Reality firewall bypassed.`,
    whoami:()=>`You are ${username}, Neural Operative. Rank: Elite. Avatar: Cyber Witch.`,
    x:()=>{ window.open('https://x.com/brandon_manus','_blank'); return 'Opening X...'; },
    youtube:()=>{ window.open('https://www.youtube.com/@brandonmanus','_blank'); return 'Opening YouTube...'; },
    project89:()=>{ window.open('https://www.project89.org/','_blank'); return 'Opening Project89...'; },
    play:()=>{ window.open('https://brandonmanus.com/play/','_blank'); return 'Opening play...'; }
  };

  function print(line){ const div=document.createElement('div'); div.textContent=line; terminalOutput.appendChild(div); terminalOutput.scrollTop=terminalOutput.scrollHeight; }

  terminalInput.addEventListener('keydown',e=>{
    if(e.key==='Enter'){
      const cmdLine = terminalInput.value.trim();
      if(!cmdLine) return;
      print(`> ${cmdLine}`);
      terminalInput.value='';
      const parts = cmdLine.split(' ').filter(Boolean);
      const cmd = parts[0];
      const args = parts.slice(1);
      const handler = commands[cmd];
      if(typeof handler === 'function'){
        try { const result = handler(args); if(result) print(result); } 
        catch (err) { print(`Error: ${err.message}`); }
      } else {
        print(`Command not found: ${cmd}`);
      }
    }
  });
});
</script>

</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
<title>Cybernetic Node v4.0 - Mobile</title>
<style>
  body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#000; color:#0f0; font-family:'Orbitron', monospace; }

  /* MAIN */
  #mainContent { display:block; position:relative; height:100%; width:100%; }

  #matrixCanvas, #particleCanvas { position:absolute; top:0; left:0; width:100%; height:100%; }
  #matrixCanvas { z-index:0; opacity:0.12; pointer-events:none; }
  #particleCanvas { z-index:1; pointer-events:none; }

  /* ensure avatar sits above the animated text */
  #avatarContainer {
    position:absolute; top:6%; left:50%; transform:translateX(-50%);
    z-index:4; opacity:0; transition:opacity 1.2s ease-in-out;
  }
  #avatarImg {
    width:180px; height:180px; border-radius:50%;
    border:3px solid #00ff88; box-shadow:0 0 20px #00ff88, inset 0 0 10px rgba(0,255,0,0.3);
    transition:all .4s;
  }
  #avatarContainer:hover #avatarImg { transform:scale(1.05); box-shadow:0 0 30px #00ffaa, 0 0 50px rgba(0,255,200,.5); }

  /* displayText positioned below the avatar; z-index lower so avatar is always on top */
  #displayText {
    position:absolute; left:50%; transform:translateX(-50%);
    color:#00ff88; font-size:1em; white-space:pre-line; z-index:3; text-align:center; padding:0 10px;
  }

  #terminal {
    position:absolute; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,0.85); border:1px solid #0f0; padding:8px 10px;
    width:92%; max-width:420px; color:#0f0; font-family:monospace; font-size:13px;
    display:none; z-index:7; border-radius:8px;
  }
  #terminalOutput { max-height:120px; overflow-y:auto; margin-bottom:5px; }
  #terminalInput { width:95%; background:#000; color:#0f0; border:none; outline:none; }

  /* CRYPTO - make compact and scrollable on narrow screens so it doesn't take too much height */
  .crypto-dashboard-wrapper {
    position:absolute; bottom:3%; left:50%; transform:translateX(-50%);
    z-index:5; width:95%; max-width:900px;
  }
  .crypto-dashboard-container {
    display:flex; gap:12px; justify-content:flex-start; align-items:center;
    overflow-x:auto; padding:6px 4px; box-sizing:border-box;
    font-family:'Orbitron', sans-serif;
  }
  .crypto-card {
    background:rgba(0,0,0,0.6); border:2px solid #00ffea; border-radius:12px;
    padding:8px 10px; flex:0 0 120px; min-width:110px; height:64px; text-align:center; color:#00ffea;
    box-shadow:0 0 12px #00ffea; transition:.2s; display:flex; flex-direction:column; justify-content:center;
  }
  .crypto-card:hover { box-shadow:0 0 25px #ff00ff; transform:translateY(-3px); }
  .crypto-card h2 { margin:0; font-size:0.95em; letter-spacing:1px; }
  .crypto-card .price { font-size:1.1em; font-weight:bold; margin:2px 0 0 0; }

  /* MOBILE SPECIFIC */
  @media(max-width:600px){
    #avatarImg { width:150px; height:150px; }
    #displayText { font-size:0.9em; }
    #terminal { max-width:94%; font-size:12px; padding:6px 8px; }
    .crypto-card { flex:0 0 110px; min-width:100px; padding:8px; height:60px; }
    .crypto-card .price { font-size:1em; }
  }
</style>
</head>
<body>

<div id="mainContent">
  <canvas id="matrixCanvas"></canvas>
  <canvas id="particleCanvas"></canvas>

  <div id="avatarContainer">
    <img id="avatarImg" src="https://na-assets.pinit.io/8GwrpeSH4TpAGEJsmoF35J8DY6RNCdyjCBZsEnTySEKd/c746a7a7-88cc-4677-b919-877329e2dd0d/437" />
  </div>

  <div id="displayText">Initializing Neural Link...</div>

  <div id="terminal">
    <div id="terminalOutput"></div>
    <div><span>&gt; </span><input id="terminalInput" type="text" autocomplete="off"/></div>
  </div>

  <div class="crypto-dashboard-wrapper">
    <div id="crypto-dashboard" class="crypto-dashboard-container">
      <div class="crypto-card" id="btc-card"><h2>BTC</h2><p class="price">$0</p></div>
      <div class="crypto-card" id="eth-card"><h2>ETH</h2><p class="price">$0</p></div>
      <div class="crypto-card" id="sol-card"><h2>SOL</h2><p class="price">$0</p></div>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const displayText = document.getElementById('displayText');
  const avatarContainer = document.getElementById('avatarContainer');
  const avatarImg = document.getElementById('avatarImg');
  const terminal = document.getElementById('terminal');
  const terminalInput = document.getElementById('terminalInput');
  const terminalOutput = document.getElementById('terminalOutput');
  const matrixCanvas = document.getElementById('matrixCanvas');
  const mctx = matrixCanvas.getContext('2d');
  const particleCanvas = document.getElementById('particleCanvas');
  const pctx = particleCanvas.getContext('2d');
  const cryptoWrapper = document.querySelector('.crypto-dashboard-wrapper');

  let username = "Echo"; // default username

  const chars = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';

  let fontSize = window.innerWidth < 600 ? 10 : 14;
  let columns = Math.floor(window.innerWidth / fontSize);
  let drops = Array(columns).fill(1);

  function resize() {
    matrixCanvas.width = particleCanvas.width = window.innerWidth;
    matrixCanvas.height = particleCanvas.height = window.innerHeight;
    fontSize = window.innerWidth < 600 ? 10 : 14;
    columns = Math.floor(matrixCanvas.width / fontSize);
    drops = Array(columns).fill(1);

    // reposition displayText below avatar and keep terminal above crypto area
    positionDisplayText();
    positionTerminal();
  }
  window.addEventListener('resize', resize);
  resize();

  function positionDisplayText(){
    // place displayText just below avatar container to avoid overlap
    try {
      const avatarRectTop = avatarContainer.offsetTop;
      const avatarH = avatarImg.offsetHeight || 180;
      const gap = 10;
      const topPx = avatarRectTop + avatarH + gap;
      displayText.style.top = topPx + 'px';
    } catch (e) {
      // fallback
      displayText.style.top = 'calc(6% + 190px)';
    }
  }

  function positionTerminal(){
    // ensure terminal sits above the crypto dashboard so it won't cover it
    try {
      const cryptoH = cryptoWrapper.offsetHeight || 80;
      const gap = 18;
      terminal.style.bottom = (cryptoH + gap) + 'px';
    } catch (e) {
      terminal.style.bottom = '18%';
    }
  }

  function bootSequence() {
    const messages = [`User ${username} recognized...`, "Decrypting neural matrix...", "Stabilizing data stream...", "Neural link established.", "Type help for more info"];
    let i=0;
    function typeNext() {
      if(i>=messages.length) {
        avatarContainer.style.opacity=1;
        terminal.style.display='block';
        terminalInput.focus();
        startMatrix();
        startParticles();
        fetchCrypto();
        setInterval(fetchCrypto,5000);

        // after avatar becomes visible, recalc positions
        setTimeout(()=>{ positionDisplayText(); positionTerminal(); }, 120);
        return;
      }
      let j=0; displayText.textContent="";
      function typer() {
        if(j<messages[i].length){ displayText.textContent+=messages[i][j++]; setTimeout(typer,30); }
        else { i++; setTimeout(typeNext,500); }
      }
      typer();
    }
    typeNext();
  }
  bootSequence();

  function startMatrix() {
    function drawMatrix() {
      mctx.fillStyle='rgba(0,0,0,0.07)'; mctx.fillRect(0,0,matrixCanvas.width,matrixCanvas.height);
      mctx.fillStyle='#00ff88'; mctx.shadowColor='#00ff88'; mctx.shadowBlur=8;
      mctx.font=fontSize+"px monospace";
      for(let i=0;i<drops.length;i++){
        const text=chars[Math.floor(Math.random()*chars.length)];
        mctx.fillText(text,i*fontSize,drops[i]*fontSize);
        if(drops[i]*fontSize>matrixCanvas.height && Math.random()>0.975) drops[i]=0;
        drops[i]++;
      }
    }
    setInterval(drawMatrix,50);
  }

  let particles=[], mouse={x:window.innerWidth/2,y:window.innerHeight/2};
  window.addEventListener('mousemove',e=>{ mouse.x=e.clientX; mouse.y=e.clientY; });
  class Particle {
    constructor(){ 
      this.x=Math.random()*particleCanvas.width; 
      this.y=Math.random()*particleCanvas.height; 
      this.size=Math.random()*2+1; 
      this.speedX=Math.random()-0.5; 
      this.speedY=Math.random()-0.5; 
    }
    update(){
      this.x += this.speedX + (mouse.x - this.x) * 0.001;
      this.y += this.speedY + (mouse.y - this.y) * 0.001;
      if(this.x < 0 || this.x > particleCanvas.width) this.speedX *= -1;
      if(this.y < 0 || this.y > particleCanvas.height) this.speedY *= -1;
    }
    draw(){ pctx.fillStyle="rgba(0,255,200,0.2)"; pctx.beginPath(); pctx.arc(this.x,this.y,this.size,0,Math.PI*2); pctx.fill(); }
  }
  function startParticles(num=window.innerWidth<600?80:180){ particles=[]; for(let i=0;i<num;i++) particles.push(new Particle()); animate(); }
  function animate(){ pctx.fillStyle="rgba(0,0,0,0.06)"; pctx.fillRect(0,0,particleCanvas.width,particleCanvas.height); particles.forEach(p=>{p.update();p.draw();}); requestAnimationFrame(animate); }

  async function fetchCrypto(){
    try{
      const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,solana&vs_currencies=usd');
      const data = await res.json();
      const formatPrice = (price) => `$${Math.floor(price).toLocaleString()}`;
      document.querySelector('#btc-card .price').textContent = formatPrice(data.bitcoin.usd);
      document.querySelector('#eth-card .price').textContent = formatPrice(data.ethereum.usd);
      document.querySelector('#sol-card .price').textContent = formatPrice(data.solana.usd);
      // if sizes change because of numbers, reposition terminal
      setTimeout(positionTerminal, 40);
    } catch {
      document.querySelectorAll('.crypto-card .price').forEach(p => p.textContent = "$Err");
    }
  }

  const commands = {
    help:()=>`Available commands: help | clear | status | scan | echo [msg] | hack | whoami | x | youtube | project89 | play`,
    clear:()=>{ terminalOutput.innerHTML=''; return ''; },
    status:()=>`Node: ACTIVE | User: ${username} | Link: SECURE | Uptime: ${Math.floor(performance.now()/1000)}s`,
    scan:()=>`Scanning neural net... [OK] Avatar Core | [OK] Quantum Relay | [OK] 127.0.0.1`,
    echo:(args)=> args.join(' '),
    hack:()=>`ACCESS GRANTED. Reality firewall bypassed.`,
    whoami:()=>`You are ${username}, Neural Operative. Rank: Elite. Avatar: Cyber Witch.`,
    x:()=>{ window.open('https://x.com/brandon_manus','_blank'); return 'Opening X...'; },
    youtube:()=>{ window.open('https://www.youtube.com/@brandonmanus','_blank'); return 'Opening YouTube...'; },
    project89:()=>{ window.open('https://www.project89.org/','_blank'); return 'Opening Project89...'; },
    play:()=>{ window.open('https://brandonmanus.com/play/','_blank'); return 'Opening play...'; }
  };

  function print(line){ const div=document.createElement('div'); div.textContent=line; terminalOutput.appendChild(div); terminalOutput.scrollTop=terminalOutput.scrollHeight; }

  terminalInput.addEventListener('keydown',e=>{
    if(e.key==='Enter'){
      const cmdLine = terminalInput.value.trim();
      if(!cmdLine) return;
      print(`> ${cmdLine}`);
      terminalInput.value='';
      const parts = cmdLine.split(' ').filter(Boolean);
      const cmd = parts[0];
      const args = parts.slice(1);
      const handler = commands[cmd];
      if(typeof handler === 'function'){
        try { const result = handler(args); if(result) print(result); } 
        catch (err) { print(`Error: ${err.message}`); }
      } else {
        print(`Command not found: ${cmd}`);
      }
    }
  });
});
</script>

</body>
</html>
