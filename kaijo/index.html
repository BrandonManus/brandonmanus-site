<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberReflex: Firewall</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&display=swap');

        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #050a14;
            color: #e2e8f0;
            overflow: hidden;
            user-select: none;
            cursor: text; /* Default cursor for typing */
        }

        #matrixCanvas {
            position: absolute; top: 0; left: 0; z-index: 0; opacity: 0.15;
        }
        #gameCanvas {
            position: relative; z-index: 10;
        }

        .scanlines {
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
            position: absolute; inset: 0; pointer-events: none; z-index: 20;
        }

        /* Defense Mode Overlay */
        #defenseOverlay {
            pointer-events: none;
            transition: opacity 0.2s;
            background: radial-gradient(circle, transparent 0%, rgba(225, 29, 72, 0.3) 100%);
            box-shadow: inset 0 0 100px rgba(225, 29, 72, 0.5);
        }
        .breach-active body {
            cursor: crosshair !important; /* Switch to crosshair only during breach */
        }

        .neon-text { text-shadow: 0 0 10px rgba(6, 182, 212, 0.8); }
        .neon-danger { text-shadow: 0 0 15px rgba(244, 63, 94, 1); }

        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            20%, 80% { transform: translate3d(4px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-6px, 0, 0); }
            40%, 60% { transform: translate3d(6px, 0, 0); }
        }

        .glitch-text { position: relative; }
        .glitch-text::before, .glitch-text::after {
            content: attr(data-text); position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #050a14;
        }
        .glitch-text::before { left: 2px; text-shadow: -1px 0 #ff00c1; animation: glitch-anim-1 2s infinite linear alternate-reverse; }
        .glitch-text::after { left: -2px; text-shadow: -1px 0 #00fff9; animation: glitch-anim-2 3s infinite linear alternate-reverse; }
    </style>
</head>
<body class="h-screen w-screen relative bg-black">

    <canvas id="matrixCanvas"></canvas>
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>

    <!-- Defense/Breach Overlay -->
    <div id="defenseOverlay" class="absolute inset-0 opacity-0 z-15 flex items-center justify-center">
        <div class="text-center pointer-events-none">
            <h1 class="text-6xl font-black text-rose-500 neon-danger mb-2 tracking-tighter">SECURITY BREACH</h1>
            <p class="text-rose-300 tracking-[0.5em] font-bold animate-pulse">MANUAL OVERRIDE REQUIRED</p>
        </div>
    </div>

    <!-- HUD -->
    <div class="absolute top-0 left-0 w-full p-6 flex justify-between items-start pointer-events-none z-30">
        <div class="bg-slate-900/80 border border-cyan-500/30 p-4 rounded-lg min-w-[140px]">
            <div class="text-xs text-slate-400 uppercase tracking-widest mb-1">Lines Hacked</div>
            <div id="scoreDisplay" class="text-4xl font-bold text-cyan-400 neon-text">0</div>
        </div>

        <!-- Active Word Display (Bottom Center) -->
        <div id="typingFocus" class="absolute bottom-12 left-1/2 transform -translate-x-1/2 text-center transition-opacity duration-200 opacity-0">
            <div class="text-[10px] text-cyan-500 mb-1 tracking-[0.3em] uppercase">Current Node</div>
            <div id="lockedWordDisplay" class="text-5xl font-bold text-white bg-black/80 px-8 py-4 rounded border-b-4 border-cyan-500 shadow-[0_0_30px_rgba(6,182,212,0.4)]"></div>
        </div>

        <div class="bg-slate-900/80 border border-cyan-500/30 p-4 rounded-lg text-right min-w-[160px]">
            <div class="text-xs text-slate-400 uppercase tracking-widest mb-2">System Integrity</div>
            <div class="flex space-x-1 justify-end" id="healthContainer"></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="absolute inset-0 flex items-center justify-center z-50 bg-black/90 backdrop-blur-sm">
        <div class="max-w-2xl w-full p-8 text-center relative border border-slate-800 bg-slate-900/50 rounded-xl">
            <h1 class="text-7xl font-black text-white mb-2 glitch-text tracking-tighter" data-text="CYBER//HACK">CYBER//HACK</h1>
            <p class="text-cyan-500 text-lg mb-10 tracking-[0.3em] uppercase">Infiltration Protocol</p>
            
            <div class="flex flex-col gap-6 mb-12 text-left max-w-md mx-auto">
                <div class="flex items-start gap-4">
                    <div class="bg-cyan-900/30 p-3 rounded text-cyan-400 font-bold">1</div>
                    <div>
                        <div class="text-white font-bold mb-1">Type to Hack</div>
                        <p class="text-slate-400 text-sm">Type falling words to infiltrate the system. It's low stress.</p>
                    </div>
                </div>
                <div class="flex items-start gap-4">
                    <div class="bg-rose-900/30 p-3 rounded text-rose-400 font-bold">2</div>
                    <div>
                        <div class="text-white font-bold mb-1">Breach Protocol</div>
                        <p class="text-slate-400 text-sm">If you miss a word, the alarm sounds! <span class="text-rose-400 font-bold">Click the red nodes</span> quickly to save your life.</p>
                    </div>
                </div>
            </div>

            <button id="startBtn" class="px-12 py-4 bg-cyan-600 hover:bg-cyan-500 text-white font-bold text-xl tracking-widest rounded transition-all shadow-[0_0_30px_rgba(8,145,178,0.4)]">
                START HACK
            </button>
        </div>
    </div>

    <!-- Game Over -->
    <div id="gameOverScreen" class="hidden absolute inset-0 flex items-center justify-center z-50 bg-black/95 backdrop-blur-md">
        <div class="p-10 text-center border-2 border-rose-600 bg-slate-900 max-w-lg w-full rounded-lg shadow-[0_0_50px_rgba(225,29,72,0.3)]">
            <h2 class="text-5xl font-black text-white mb-2">DISCONNECTED</h2>
            <div class="text-rose-500 mb-8 tracking-[0.5em] uppercase text-sm">Signal Lost</div>
            <div class="text-xs text-slate-500 mb-2">FINAL SCORE</div>
            <div id="finalScore" class="text-5xl font-bold text-white mb-8">0</div>
            <button id="restartBtn" class="w-full py-4 bg-slate-800 hover:bg-slate-700 text-white font-bold rounded border border-slate-600 transition-all tracking-widest">
                RE-INITIALIZE
            </button>
        </div>
    </div>

    <script>
        // --- AUDIO ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(key) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            const sounds = {
                type: () => { // Subtle click
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, now);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                },
                complete: () => { // Satisfying blip
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                },
                alarm: () => { // Low breach alarm
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.linearRampToValueAtTime(100, now + 0.5);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                },
                shoot: () => { // Zap
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                },
                fail: () => { // Crunch
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(80, now);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                    osc.start(now);
                    osc.stop(now + 0.4);
                }
            };
            if(sounds[key]) sounds[key]();
        }

        // --- DATA & CONFIG ---
        const WORDS = [
            "admin", "root", "user", "pass", "hack", "code", "java", "node", "flux", "grid", 
            "data", "byte", "bit", "link", "sync", "host", "port", "void", "null", "main",
            "cyber", "proxy", "shell", "bash", "stack", "queue", "heap", "logic", "loop",
            "while", "break", "catch", "throw", "async", "await", "const", "class", "super",
            "import", "export", "return", "static", "public", "private", "switch", "typeof",
            "access", "denied", "system", "kernel", "memory", "buffer", "socket", "thread",
            "script", "cookie", "token", "crypto", "cipher", "hacker", "server", "client",
            "config", "deploy", "docker", "python", "rust", "react", "build", "debug"
        ];

        const CONFIG = {
            spawnRate: 1800, // Relaxed start
            fallSpeed: 0.5,  // Relaxed start
            colors: {
                word: '#94a3b8',
                wordLocked: '#ffffff',
                wordTyped: '#22d3ee', // Cyan
                breach: '#f43f5e'     // Rose
            },
            maxHealth: 3
        };

        // --- STATE ---
        const state = {
            phase: 'hacking', // 'hacking' or 'breach'
            words: [],
            breachTargets: [],
            health: CONFIG.maxHealth,
            score: 0,
            activeWord: null,
            spawnTimer: 0,
            lastTime: 0,
            breachTimer: 0,
            particles: []
        };

        // --- CLASSES ---
        class WordTarget {
            constructor() {
                this.text = WORDS[Math.floor(Math.random() * WORDS.length)];
                ctx.font = "bold 24px 'JetBrains Mono'";
                this.width = ctx.measureText(this.text).width;
                this.x = Math.random() * (canvas.width - this.width - 100) + 50;
                this.y = -30;
                this.typedIdx = 0;
                this.speed = CONFIG.fallSpeed + (Math.random() * 0.2);
            }
            draw(ctx) {
                ctx.font = "bold 24px 'JetBrains Mono'";
                
                const isActive = state.activeWord === this;
                
                // Background pill
                const pad = 10;
                ctx.fillStyle = isActive ? 'rgba(6, 182, 212, 0.15)' : 'rgba(15, 23, 42, 0.6)';
                ctx.beginPath();
                ctx.roundRect(this.x - pad, this.y - 24, this.width + (pad*2), 34, 4);
                ctx.fill();
                if(isActive) {
                    ctx.strokeStyle = 'rgba(6, 182, 212, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Text
                const done = this.text.substring(0, this.typedIdx);
                const rest = this.text.substring(this.typedIdx);
                
                ctx.fillStyle = CONFIG.colors.wordTyped;
                ctx.fillText(done, this.x, this.y);
                
                ctx.fillStyle = isActive ? CONFIG.colors.wordLocked : CONFIG.colors.word;
                ctx.fillText(rest, this.x + ctx.measureText(done).width, this.y);
            }
            update() {
                this.y += this.speed;
                return this.y > canvas.height + 20; // Return true if offscreen
            }
        }

        class BreachNode {
            constructor() {
                this.x = Math.random() * (canvas.width - 100) + 50;
                this.y = Math.random() * (canvas.height - 100) + 50;
                this.radius = 40;
                this.born = performance.now();
                this.life = 2000; // 2 seconds to click
            }
            draw(ctx) {
                const age = performance.now() - this.born;
                const lifePct = 1 - (age / this.life);
                
                // Shrinking ring
                ctx.strokeStyle = CONFIG.colors.breach;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * lifePct, 0, Math.PI*2);
                ctx.stroke();

                // Static core
                ctx.fillStyle = 'rgba(244, 63, 94, 0.5)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 10, 0, Math.PI*2);
                ctx.fill();
            }
            checkHit(x, y) {
                return Math.hypot(this.x - x, this.y - y) < 40; // Forgive hit area
            }
            isDead() {
                return (performance.now() - this.born) > this.life;
            }
        }

        // --- GAME LOGIC ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Matrix BG setup
            const mCanvas = document.getElementById('matrixCanvas');
            mCanvas.width = window.innerWidth;
            mCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);

        function spawnWord() {
            state.words.push(new WordTarget());
            state.spawnTimer = 0;
        }

        function triggerBreach() {
            state.phase = 'breach';
            state.breachTargets = [];
            // Clear the word that failed us
            state.words = state.words.filter(w => w.y < canvas.height);
            state.activeWord = null;
            
            // Spawn 3 safety nodes
            for(let i=0; i<3; i++) state.breachTargets.push(new BreachNode());
            
            // UI
            document.getElementById('defenseOverlay').style.opacity = '1';
            document.body.classList.add('breach-active');
            document.getElementById('gameCanvas').style.filter = 'blur(4px)';
            playSound('alarm');
        }

        function resolveBreach(success) {
            state.phase = 'hacking';
            state.breachTargets = [];
            
            document.getElementById('defenseOverlay').style.opacity = '0';
            document.body.classList.remove('breach-active');
            document.getElementById('gameCanvas').style.filter = 'none';
            
            if(success) {
                playSound('complete');
            } else {
                takeDamage();
            }
        }

        function takeDamage() {
            state.health--;
            playSound('fail');
            updateHUD();
            document.body.classList.add('shake');
            setTimeout(()=>document.body.classList.remove('shake'), 400);
            
            if(state.health <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            state.phase = 'gameover';
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('finalScore').textContent = state.score;
        }

        // --- INPUTS ---
        window.addEventListener('keydown', (e) => {
            if(state.phase !== 'hacking') return;
            if(e.ctrlKey || e.altKey || e.metaKey) return;
            
            const key = e.key.toLowerCase();
            if(key.length !== 1) return;

            if(state.activeWord) {
                // Typing locked word
                const w = state.activeWord;
                if(w.text[w.typedIdx] === key) {
                    w.typedIdx++;
                    playSound('type');
                    if(w.typedIdx >= w.text.length) {
                        // Word cleared
                        state.words = state.words.filter(word => word !== w);
                        state.activeWord = null;
                        state.score += 1;
                        playSound('complete');
                        updateHUD();
                    }
                }
            } else {
                // Find new word
                // Prioritize lowest word that starts with key
                const candidates = state.words.filter(w => w.text.startsWith(key));
                if(candidates.length > 0) {
                    candidates.sort((a,b) => b.y - a.y); // Lowest first
                    state.activeWord = candidates[0];
                    state.activeWord.typedIdx = 1;
                    playSound('type');
                    // Check if 1 letter word (edge case)
                    if(state.activeWord.text.length === 1) {
                         state.words = state.words.filter(word => word !== state.activeWord);
                         state.activeWord = null;
                         state.score += 1;
                    }
                }
            }
            updateHUD();
        });

        window.addEventListener('mousedown', (e) => {
            if(state.phase !== 'breach') return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check clicks on breach nodes
            for(let i=state.breachTargets.length-1; i>=0; i--) {
                const t = state.breachTargets[i];
                if(t.checkHit(x, y)) {
                    state.breachTargets.splice(i, 1);
                    playSound('shoot');
                    if(state.breachTargets.length === 0) {
                        resolveBreach(true); // Success!
                    }
                    return;
                }
            }
        });

        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = state.score;
            
            const hCont = document.getElementById('healthContainer');
            hCont.innerHTML = '';
            for(let i=0; i<CONFIG.maxHealth; i++) {
                const pip = document.createElement('div');
                pip.className = `w-8 h-2 rounded-sm skew-x-12 ${i < state.health ? 'bg-cyan-400 shadow-[0_0_5px_cyan]' : 'bg-slate-800'}`;
                hCont.appendChild(pip);
            }

            const focus = document.getElementById('typingFocus');
            const focusText = document.getElementById('lockedWordDisplay');
            
            if(state.activeWord) {
                focus.style.opacity = 1;
                const w = state.activeWord;
                const done = w.text.substring(0, w.typedIdx);
                const curr = w.text.substring(w.typedIdx, w.typedIdx+1);
                const rest = w.text.substring(w.typedIdx+1);
                focusText.innerHTML = `<span class="text-cyan-400">${done}</span><span class="text-white border-b-2 border-white">${curr}</span><span class="text-slate-600">${rest}</span>`;
            } else {
                focus.style.opacity = 0;
            }
        }

        // --- MATRIX BACKGROUND ---
        const mCanvas = document.getElementById('matrixCanvas');
        const mCtx = mCanvas.getContext('2d');
        let drops = [];
        function initMatrix() {
            mCanvas.width = window.innerWidth;
            mCanvas.height = window.innerHeight;
            drops = Array(Math.floor(mCanvas.width/20)).fill(1);
        }
        initMatrix();

        function drawMatrix() {
            mCtx.fillStyle = 'rgba(5, 10, 20, 0.1)';
            mCtx.fillRect(0, 0, mCanvas.width, mCanvas.height);
            mCtx.fillStyle = '#0f0';
            mCtx.font = '14px monospace';
            for(let i=0; i<drops.length; i++) {
                const text = String.fromCharCode(0x30A0 + Math.random()*96);
                mCtx.fillStyle = Math.random() > 0.95 ? '#fff' : '#15803d';
                mCtx.fillText(text, i*20, drops[i]*20);
                if(drops[i]*20 > mCanvas.height && Math.random() > 0.975) drops[i] = 0;
                drops[i]++;
            }
        }

        // --- MAIN LOOP ---
        function loop(timestamp) {
            if(state.phase === 'gameover') return;
            const dt = timestamp - state.lastTime;
            state.lastTime = timestamp;

            // Matrix BG (runs independently)
            if(Math.floor(timestamp/50) !== Math.floor((timestamp-dt)/50)) drawMatrix();

            // Logic
            if(state.phase === 'hacking') {
                // Spawn words
                state.spawnTimer += dt;
                if(state.spawnTimer > CONFIG.spawnRate) {
                    spawnWord();
                    // Gently increase difficulty
                    CONFIG.spawnRate = Math.max(800, CONFIG.spawnRate * 0.995);
                }

                ctx.clearRect(0,0,canvas.width, canvas.height);

                // Update Words
                for(let i=state.words.length-1; i>=0; i--) {
                    const w = state.words[i];
                    const fail = w.update();
                    w.draw(ctx);
                    
                    if(fail) {
                        triggerBreach();
                        break;
                    }
                }
            } 
            else if (state.phase === 'breach') {
                // Just clear for breach overlay clarity or keep words frozen in bg?
                // Let's redraw words static to show "paused" state
                ctx.clearRect(0,0,canvas.width, canvas.height);
                state.words.forEach(w => w.draw(ctx)); // Static draw
                
                // Draw Breach Nodes
                for(let i=state.breachTargets.length-1; i>=0; i--) {
                    const t = state.breachTargets[i];
                    t.draw(ctx);
                    if(t.isDead()) {
                        // Time ran out on a node!
                        resolveBreach(false); // Fail
                        break;
                    }
                }
            }

            requestAnimationFrame(loop);
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            
            state.phase = 'hacking';
            state.score = 0;
            state.health = CONFIG.maxHealth;
            state.words = [];
            state.activeWord = null;
            state.spawnTimer = 0;
            state.lastTime = performance.now();
            CONFIG.spawnRate = 1800; // Reset speed

            resize();
            updateHUD();
            requestAnimationFrame(loop);
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            startGame();
        });
        document.getElementById('restartBtn').addEventListener('click', startGame);
        window.addEventListener('resize', resize);

    </script>
</body>
</html>
