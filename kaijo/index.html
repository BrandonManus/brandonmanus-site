<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberReflex: Aim & Type</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&display=swap');

        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
            user-select: none;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .ui-panel {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(56, 189, 248, 0.3);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.1);
        }

        .neon-text {
            text-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }

        .neon-danger {
            text-shadow: 0 0 10px rgba(244, 63, 94, 0.5);
        }
        
        /* Shake animation for wrong typing */
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
    </style>
</head>
<body class="h-screen w-screen relative">

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD Overlay -->
    <div id="hud" class="absolute top-0 left-0 w-full p-6 flex justify-between items-start pointer-events-none">
        <div class="ui-panel p-4 rounded-lg">
            <div class="text-xs text-slate-400 uppercase tracking-widest mb-1">Score</div>
            <div id="scoreDisplay" class="text-4xl font-bold text-cyan-400 neon-text">0</div>
        </div>
        
        <div class="flex flex-col items-center space-y-2">
            <div class="ui-panel px-6 py-2 rounded-full border-t-2 border-cyan-500">
                <span id="gameModeDisplay" class="text-sm font-bold tracking-widest text-white">MIXED MODE</span>
            </div>
            <div id="comboContainer" class="opacity-0 transition-opacity duration-300">
                <div class="text-yellow-400 font-black text-2xl italic transform -skew-x-12">x<span id="comboDisplay">1</span></div>
            </div>
        </div>

        <div class="ui-panel p-4 rounded-lg text-right">
            <div class="text-xs text-slate-400 uppercase tracking-widest mb-1">Health</div>
            <div class="flex space-x-1 justify-end" id="healthContainer">
                <!-- Health bars generated by JS -->
            </div>
            <div class="mt-2 text-xs text-slate-500">WPM: <span id="wpmDisplay" class="text-white">0</span></div>
        </div>
    </div>

    <!-- Locked Target Indicator (Bottom Center) -->
    <div id="typingFocus" class="absolute bottom-10 left-1/2 transform -translate-x-1/2 text-center opacity-0 transition-opacity duration-100 pointer-events-none">
        <div class="text-xs text-cyan-300 mb-1 tracking-widest">LOCKED TARGET</div>
        <div id="lockedWordDisplay" class="text-3xl font-bold text-white bg-black/50 px-4 py-2 rounded border border-cyan-500/50">
            <span class="text-slate-500">GHO</span><span class="text-white animate-pulse">ST</span>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="absolute inset-0 flex items-center justify-center z-50 bg-slate-900/95 backdrop-blur-sm">
        <div class="max-w-2xl w-full p-8 text-center">
            <h1 class="text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500 mb-2 neon-text">CYBER REFLEX</h1>
            <p class="text-slate-400 text-lg mb-8 tracking-wide">NEURAL LINK CALIBRATION PROTOCOL</p>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-10">
                <div class="ui-panel p-6 rounded-xl border border-rose-500/30 hover:border-rose-500/80 transition-colors group">
                    <div class="text-rose-400 font-bold text-xl mb-2 group-hover:text-rose-300">AIM TARGETS</div>
                    <div class="w-12 h-12 rounded-full bg-rose-500 mx-auto mb-3 animate-pulse shadow-[0_0_15px_rgba(244,63,94,0.6)]"></div>
                    <p class="text-sm text-slate-400">Click the <span class="text-rose-400">RED ORBS</span> before they shrink.</p>
                </div>
                
                <div class="ui-panel p-6 rounded-xl border border-cyan-500/30 hover:border-cyan-500/80 transition-colors group">
                    <div class="text-cyan-400 font-bold text-xl mb-2 group-hover:text-cyan-300">TYPE TARGETS</div>
                    <div class="w-12 h-12 rounded bg-cyan-500 mx-auto mb-3 shadow-[0_0_15px_rgba(34,211,238,0.6)] flex items-center justify-center text-black font-bold text-xs">CMD</div>
                    <p class="text-sm text-slate-400">Type the <span class="text-cyan-400">WORDS</span> to destroy blocks.</p>
                </div>
            </div>

            <button id="startBtn" class="group relative px-8 py-4 bg-cyan-600 hover:bg-cyan-500 text-white font-bold text-xl rounded-lg transition-all hover:scale-105 hover:shadow-[0_0_30px_rgba(8,145,178,0.6)] overflow-hidden">
                <span class="relative z-10">INITIALIZE SIMULATION</span>
                <div class="absolute inset-0 h-full w-full bg-gradient-to-r from-transparent via-white/20 to-transparent -translate-x-full group-hover:animate-[shimmer_1.5s_infinite]"></div>
            </button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden absolute inset-0 flex items-center justify-center z-50 bg-slate-900/90 backdrop-blur-md">
        <div class="ui-panel p-10 rounded-2xl text-center max-w-lg w-full border-2 border-slate-700">
            <h2 class="text-5xl font-bold text-white mb-2">SYSTEM FAILURE</h2>
            <div class="text-xl text-rose-500 mb-8 neon-danger">SIGNAL LOST</div>
            
            <div class="grid grid-cols-3 gap-4 mb-8">
                <div class="bg-slate-800 p-3 rounded">
                    <div class="text-xs text-slate-400">SCORE</div>
                    <div id="finalScore" class="text-2xl font-bold text-white">0</div>
                </div>
                <div class="bg-slate-800 p-3 rounded">
                    <div class="text-xs text-slate-400">ACCURACY</div>
                    <div id="finalAcc" class="text-2xl font-bold text-yellow-400">0%</div>
                </div>
                <div class="bg-slate-800 p-3 rounded">
                    <div class="text-xs text-slate-400">PEAK COMBO</div>
                    <div id="finalCombo" class="text-2xl font-bold text-purple-400">0</div>
                </div>
            </div>

            <button id="restartBtn" class="w-full py-3 bg-slate-700 hover:bg-slate-600 text-white font-bold rounded border border-slate-500 hover:border-white transition-all">
                REBOOT SYSTEM
            </button>
        </div>
    </div>

    <script>
        /**
         * CYBER REFLEX ENGINE
         * A hybrid aim-trainer and typing game.
         */

        // --- Word Database ---
        const WORD_LIST = [
            "system", "data", "cyber", "neon", "flux", "grid", "node", "hack", "code", "link",
            "core", "byte", "pixel", "laser", "tech", "mech", "void", "null", "root", "user",
            "admin", "shell", "bash", "sudo", "echo", "ping", "host", "port", "wifi", "sync",
            "load", "save", "edit", "file", "type", "click", "zoom", "pan", "scan", "read",
            "logic", "power", "drive", "chip", "gate", "wave", "pulse", "beam", "warp", "dash",
            "quantum", "neural", "matrix", "vector", "sprite", "render", "shader", "buffer", "memory", "kernel",
            "protocol", "security", "firewall", "encrypt", "decrypt", "terminal", "interface", "mainframe", "database", "algorithm",
            "sequence", "compile", "runtime", "syntax", "variable", "function", "module", "plugin", "widget", "asset"
        ];

        // --- Configuration ---
        const CONFIG = {
            spawnRate: 1200, // ms between spawns
            spawnRateMin: 400,
            decayRate: 0.98, // Spawn rate multiplier
            aimTargetLife: 2500, // ms duration for aim targets
            typeTargetSpeed: 1.5, // px per frame
            maxHealth: 5,
            colors: {
                aim: '#f43f5e', // Rose-500
                aimRing: '#fda4af', 
                type: '#06b6d4', // Cyan-500
                typeText: '#ffffff',
                typeHighlight: '#fcd34d', // Amber-300
                particle: ['#f43f5e', '#06b6d4', '#e879f9', '#ffffff']
            }
        };

        // --- Game State ---
        const state = {
            isActive: false,
            lastTime: 0,
            score: 0,
            health: CONFIG.maxHealth,
            targets: [],
            particles: [],
            lastSpawn: 0,
            currentSpawnRate: CONFIG.spawnRate,
            combo: 0,
            totalClicks: 0,
            successfulClicks: 0,
            lockedTarget: null, // The TypingTarget currently being typed
            wpmStart: 0,
            charsTyped: 0
        };

        // --- Canvas Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Classes ---

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.01;
                this.size = Math.random() * 3 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.size *= 0.95;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class AimTarget {
            constructor() {
                this.type = 'aim';
                this.radius = 40; // Max radius
                this.x = Math.random() * (canvas.width - 100) + 50;
                this.y = Math.random() * (canvas.height - 100) + 50;
                this.creationTime = performance.now();
                this.lifeDuration = CONFIG.aimTargetLife; // How long it lasts
                this.active = true;
                this.maxRadius = 40;
            }

            update(now) {
                const age = now - this.creationTime;
                const progress = age / this.lifeDuration;
                
                // Shrink effect
                this.radius = this.maxRadius * (1 - progress);

                if (progress >= 1) {
                    this.active = false;
                    takeDamage();
                }
            }

            draw(ctx) {
                // Outer glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = CONFIG.colors.aim;
                
                // Main circle
                ctx.fillStyle = CONFIG.colors.aim;
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(0, this.radius), 0, Math.PI * 2);
                ctx.fill();

                // Inner white ring (shrinks faster to create urgency visual)
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(0, this.radius * 0.6), 0, Math.PI * 2);
                ctx.stroke();

                ctx.shadowBlur = 0;
            }

            checkClick(x, y) {
                const dist = Math.hypot(this.x - x, this.y - y);
                return dist < this.radius;
            }
        }

        class TypeTarget {
            constructor() {
                this.type = 'type';
                this.word = WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)];
                this.typedIndex = 0; // How many chars typed correctly
                
                // Always spawn at top
                this.width = ctx.measureText(this.word).width + 40;
                this.height = 40;
                this.x = Math.random() * (canvas.width - this.width - 20) + 10;
                this.y = -50;
                this.speed = CONFIG.typeTargetSpeed + (Math.random() * 0.5);
                
                this.active = true;
                this.isLocked = false; // Is the player currently typing this word?
            }

            update() {
                this.y += this.speed;

                // Check if hit bottom
                if (this.y > canvas.height + 50) {
                    this.active = false;
                    if (state.isActive) takeDamage(); // Only damage if game still running
                    if (state.lockedTarget === this) releaseLock();
                }
            }

            draw(ctx) {
                ctx.font = "bold 20px 'JetBrains Mono'";
                const textWidth = ctx.measureText(this.word).width;
                const padding = 12;
                const boxWidth = textWidth + (padding * 2);
                const boxHeight = 34;

                // Draw Background Box
                ctx.fillStyle = this.isLocked ? 'rgba(6, 182, 212, 0.2)' : 'rgba(15, 23, 42, 0.6)';
                ctx.strokeStyle = this.isLocked ? CONFIG.colors.type : '#334155';
                ctx.lineWidth = this.isLocked ? 3 : 1;
                
                // Rounded Rect manually for compatibility
                ctx.beginPath();
                ctx.rect(this.x - padding, this.y - 24, boxWidth, boxHeight);
                ctx.fill();
                ctx.stroke();

                // Draw Text
                const typedPart = this.word.substring(0, this.typedIndex);
                const untypedPart = this.word.substring(this.typedIndex);

                // Draw Typed part (Green/Yellow)
                ctx.fillStyle = CONFIG.colors.typeHighlight;
                ctx.fillText(typedPart, this.x, this.y);

                // Draw Untyped part (White/Cyan)
                const typedWidth = ctx.measureText(typedPart).width;
                ctx.fillStyle = CONFIG.colors.typeText;
                ctx.fillText(untypedPart, this.x + typedWidth, this.y);
                
                // Connecting line if locked
                if (this.isLocked) {
                     ctx.beginPath();
                     ctx.moveTo(this.x + boxWidth/2 - padding, this.y + 10);
                     ctx.lineTo(canvas.width/2, canvas.height);
                     ctx.strokeStyle = 'rgba(6, 182, 212, 0.1)';
                     ctx.lineWidth = 2;
                     ctx.stroke();
                }
            }
        }

        // --- Audio System ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'type') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now); // High blip
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            } else if (type === 'kill') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'damage') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.3);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            }
        }

        // --- Core Logic ---

        function spawnTarget() {
            // 50/50 chance of aim vs type
            // Adjustment: If locked on a word, prefer aiming targets to keep screen chaotic but fair
            const chance = state.lockedTarget ? 0.7 : 0.5;
            
            if (Math.random() < chance) {
                state.targets.push(new AimTarget());
            } else {
                state.targets.push(new TypeTarget());
            }

            // Increase difficulty
            state.currentSpawnRate = Math.max(CONFIG.spawnRateMin, state.currentSpawnRate * CONFIG.decayRate);
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 12; i++) {
                state.particles.push(new Particle(x, y, color));
            }
        }

        function takeDamage() {
            state.health--;
            playSound('damage');
            updateHUD();
            
            // Screen shake effect
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 500);

            if (state.health <= 0) {
                gameOver();
            }
        }

        function addScore(points) {
            state.combo++;
            const multiplier = 1 + Math.floor(state.combo / 10) * 0.5;
            state.score += Math.floor(points * multiplier);
            updateHUD();
        }

        function resetCombo() {
            state.combo = 0;
            updateHUD();
        }

        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = state.score;
            
            // Health Bars
            const healthContainer = document.getElementById('healthContainer');
            healthContainer.innerHTML = '';
            for (let i = 0; i < CONFIG.maxHealth; i++) {
                const bar = document.createElement('div');
                bar.className = `w-3 h-8 rounded-sm transition-all duration-300 ${i < state.health ? 'bg-rose-500 shadow-[0_0_10px_rgba(244,63,94,0.8)]' : 'bg-slate-800'}`;
                healthContainer.appendChild(bar);
            }

            // Combo
            const comboEl = document.getElementById('comboContainer');
            const comboText = document.getElementById('comboDisplay');
            if (state.combo > 1) {
                comboEl.style.opacity = '1';
                comboText.textContent = state.combo;
                comboText.parentElement.style.transform = `scale(${1 + Math.min(state.combo * 0.05, 0.5)}) skewX(-12deg)`;
            } else {
                comboEl.style.opacity = '0';
            }

            // Locked Target UI
            const focusEl = document.getElementById('typingFocus');
            const focusText = document.getElementById('lockedWordDisplay');
            if (state.lockedTarget) {
                focusEl.style.opacity = '1';
                const word = state.lockedTarget.word;
                const idx = state.lockedTarget.typedIndex;
                focusText.innerHTML = `<span class="text-slate-500">${word.substring(0,idx)}</span><span class="text-white text-shadow-lg">${word.substring(idx, idx+1)}</span><span class="text-slate-300">${word.substring(idx+1)}</span>`;
            } else {
                focusEl.style.opacity = '0';
            }

            // WPM
            if (state.isActive) {
                const minutes = (performance.now() - state.wpmStart) / 60000;
                const wpm = Math.floor((state.charsTyped / 5) / minutes) || 0;
                document.getElementById('wpmDisplay').textContent = wpm;
            }
        }

        function releaseLock() {
            if (state.lockedTarget) {
                state.lockedTarget.isLocked = false;
                state.lockedTarget = null;
            }
            updateHUD();
        }

        // --- Input Handling ---

        window.addEventListener('mousedown', (e) => {
            if (!state.isActive) return;
            
            state.totalClicks++;
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            let hit = false;

            // Iterate backwards to hit top targets first
            for (let i = state.targets.length - 1; i >= 0; i--) {
                const t = state.targets[i];
                if (t.type === 'aim' && t.checkClick(clickX, clickY)) {
                    // Hit!
                    createExplosion(t.x, t.y, CONFIG.colors.aim);
                    state.targets.splice(i, 1);
                    addScore(100);
                    playSound('shoot');
                    hit = true;
                    state.successfulClicks++;
                    break; // Only hit one per click
                }
            }

            if (!hit) {
                resetCombo(); // Miss click breaks combo
            }
        });

        window.addEventListener('keydown', (e) => {
            if (!state.isActive) return;

            // Ignore modifier keys
            if (e.key.length > 1) return;

            const key = e.key.toLowerCase();

            if (state.lockedTarget) {
                // We are locked onto a specific word
                const target = state.lockedTarget;
                const expectedChar = target.word[target.typedIndex];

                if (key === expectedChar) {
                    // Correct letter
                    target.typedIndex++;
                    state.charsTyped++;
                    playSound('type');
                    
                    // Word Complete?
                    if (target.typedIndex >= target.word.length) {
                        createExplosion(target.x + 20, target.y, CONFIG.colors.type);
                        state.targets = state.targets.filter(t => t !== target);
                        addScore(150 + (target.word.length * 10));
                        playSound('kill');
                        releaseLock();
                    }
                    updateHUD();
                } else {
                    // Wrong letter on locked target
                    resetCombo();
                    // Visual feedback?
                    const focusText = document.getElementById('lockedWordDisplay');
                    focusText.classList.add('shake');
                    setTimeout(() => focusText.classList.remove('shake'), 300);
                }
            } else {
                // No lock, search for a word starting with this key
                const match = state.targets.find(t => t.type === 'type' && t.word.startsWith(key));
                if (match) {
                    state.lockedTarget = match;
                    match.isLocked = true;
                    match.typedIndex = 1; // First char already typed
                    state.charsTyped++;
                    playSound('type');
                    
                    // Edge case: 1 letter word (rare but possible)
                    if (match.word.length === 1) {
                         createExplosion(match.x, match.y, CONFIG.colors.type);
                         state.targets = state.targets.filter(t => t !== match);
                         addScore(160);
                         playSound('kill');
                         releaseLock();
                    }
                    updateHUD();
                } else {
                    // Typed a key but no word starts with it
                    // Can be strict and reset combo here, or lenient
                    // Let's be strict
                    // resetCombo(); 
                }
            }
        });

        // --- Game Loop ---

        function gameLoop(timestamp) {
            if (!state.isActive) return;

            const dt = timestamp - state.lastTime;
            state.lastTime = timestamp;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Grid Background Effect
            ctx.strokeStyle = 'rgba(56, 189, 248, 0.05)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            // Moving grid effect
            const offset = (timestamp / 50) % gridSize;
            
            ctx.beginPath();
            for(let x=0; x<canvas.width; x+=gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for(let y=offset; y<canvas.height; y+=gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();

            // Spawning Logic
            if (timestamp - state.lastSpawn > state.currentSpawnRate) {
                spawnTarget();
                state.lastSpawn = timestamp;
            }

            // Update & Draw Targets
            // Draw Type targets behind Aim targets so clicks don't get obscured visually?
            // Actually, Type targets drift, Aim targets sit. Draw aim on top.
            
            // Filter out dead targets first
            // Note: doing this in update loop carefully
            
            for (let i = state.targets.length - 1; i >= 0; i--) {
                const t = state.targets[i];
                t.update(timestamp);
                if (!t.active) {
                    state.targets.splice(i, 1);
                } else {
                    t.draw(ctx);
                }
            }

            // Particles
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.update();
                if (p.life <= 0) {
                    state.particles.splice(i, 1);
                } else {
                    p.draw(ctx);
                }
            }

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            
            // Reset State
            state.isActive = true;
            state.score = 0;
            state.health = CONFIG.maxHealth;
            state.targets = [];
            state.particles = [];
            state.combo = 0;
            state.currentSpawnRate = CONFIG.spawnRate;
            state.lastTime = performance.now();
            state.lastSpawn = performance.now();
            state.totalClicks = 0;
            state.successfulClicks = 0;
            state.charsTyped = 0;
            state.wpmStart = performance.now();
            releaseLock();

            updateHUD();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            state.isActive = false;
            document.getElementById('gameOverScreen').classList.remove('hidden');
            
            document.getElementById('finalScore').textContent = state.score;
            document.getElementById('finalCombo').textContent = state.combo;
            
            const acc = state.totalClicks > 0 ? Math.round((state.successfulClicks / state.totalClicks) * 100) : 0;
            document.getElementById('finalAcc').textContent = acc + "%";
        }

        // --- UI Bindings ---
        document.getElementById('startBtn').addEventListener('click', () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            startGame();
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            startGame();
        });

    </script>
</body>
</html>
